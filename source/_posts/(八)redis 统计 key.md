---
title: (八)redis 统计 key
date: 2022-11-12 11:34:11
index_img: /img/redis.png
categories:
  - redis
tags:
  - redis
---

### 统计能力

在实际业务场景当中,redis 出了当做缓存使用; 还经常做的事就是统计各种 `key` 相关的数据

例如:
* app 的登录用户
* 电商网站的评论,点赞,点踩等能力
* app 的签到场景

由于实际业务场景当中的请求量或者说用户规模都是巨大的,针对不同的场景选择合适的数据结构去保存这些行为数据是很值得优化的

### 集合的常用统计模式

1. 聚合统计
2. 排序统计
3. 二值状态统计
4. 基数统计

将业务场景里面的统计需求,转化抽象为上述四种模式之一,在针对性的选择合适的 redis 数据结构,能够提高 redis 的统计性能,还能减少 redis 的内存开销

#### 聚合统计

这是最常见的统计模式,其定义是: **统计多个集合元素的聚合结果** ; 其表现行为通常以 `求并集`, `求交集`, `求差集` 等等形式体现

例如统计某一天内用户的新增数量 或者 遇上一天相比的用户留存数量 或者 某一时间段之内的所有用户数量

针对含有唯一性 id 的数据,使用 redis 的集合 `set` 是非常合适的数据结构

集合 1 保存所有使用过的用户

![img.png](https://tva1.sinaimg.cn/large/008vK57jgy1h8288wgvu0j30ht0dfdhi.jpg)

对于每一天,通过加上当天的日期,用于保存当天使用过的用户数据

![img_1.png](https://tva1.sinaimg.cn/large/008vK57jgy1h82894mwmyj30hs0c70ul.jpg)

对于 `20200803` 当天新增的用户,可以用 `user:id` - `user:id:20200803` 得到

如果需要统计二天的相比前一天的留存客户,则可以使用 `user:id:20200804` ∩ `user:id:20200803` 求两个集合的交集就是 `0803` 在 `0804` 留存的客户

需要注意的一点就是, `set` 的交并补计算复杂度比较高,在数据量较大的情况下,可能会导致主线程阻塞

为了避免集合运算阻塞主线程,最好的办法是 **在集群中选择一个从库,专门执行聚合计算,或者直接把原始结果返回给调用方,让调用方在本地完成计算** ,而不要阻塞 redis 的服务

#### 排序统计

排序统计要求待统计的 `key` 按照某种规则进行排序,例如按照时间顺序的评论,或者按照点赞多少的热评,这些都属于排序统计模式

redis 支持排序的集合有两类, `List` 列表和 `Sorted Set`有序集合

对于 `List` 来说,其排序规则就是按照元素进入 `List` 的顺序决定的; 而对于 `Sorted Set` 其排序规则则是可以根据元素自定义权重值; 也就是说 `Sorted Set` 支持自定义排序

如果说需要排序统计的 `key` 本身符合一些自然的先后规律,例如时间顺序; 使用 `List` 就可以很好的支持这些元素的排序

按照时间先后顺序,每产生一条新的评论就通过 `LPUSH` 插入到 `List` 的头部,这样越远离头部的元素,就是时间越靠后的元素

但是考虑一个分页查询的场景,例如有 10 个元素,分别是 `[1,10]` 如果一页展示 3 个元素

那么第一页就是 `LRANGE comments 0 2` = [1,3], 第二页就是 `LRANGE comments 3 5` [4,6]

ok,这看起来没什么问题,那如果说此时一条新的评论产生,这样原先的集合变为 [11,1] [1,10],再使用第二页的命令就会把之前第一页的评论 `3` 查询出来,相当于读取到了旧元素

`Sorted Set` 排序集合可以实现自定义权重值排序,对于频繁地更新元素和增删元素,也能通过 `ZRANGEBYSCORE` 命令准确地获取排序后范围的元素

#### 二值状态统计

什么叫 `二值状态统计`: 即统计元素只有 `0` 和 `1` 两种状态

常见的运用就是统计打卡签到场景

对于每天的打卡或者签到场景来说,一个月也才 30 天,一年也才 365 天,只需要使用一个 `bitmap` 位图的数据结构即可实现; redis 原生提供了扩展类型数据结构 `bitmap`

把每天映射到 `bitmap` 的每一位上,如果当前位 = 1,则表示当天有过打卡,否则表示当天没有打卡

而且使用命令 `BITCOUNT` 可以快速的统计当前 `bitmap` 里面 `1` 的个数(具体计算公式猜想为 `while(n>0) k=n&(n-1) `,其中 n 为位图最终表示的数据,k 为 1 的个数)

#### 基数统计

基数统计就是用于统计那些集合内不重复的元素个数,看起来与聚合统计很相似; 很容易就能想到通过 `set` 或者 `hash` 来保存数据

但实际上当数据量非常巨大时,单个 `set` 或者 `hash` 结构将会消耗非常多的内存

redis 提供了一个专门用于基数统计的数据结构 `HyperLogLog`, 有着固定大小的内存消耗,大约在 `12KB` 左右,但是能够统计超过 `2^64` 个元素

虽然 `HyperLogLog` 有着很低的内存使用率,但是其实现原理是基于统计计算的,与实际值存在偏差

如果说统计结果需要准确的数据,就不得不使用 `set` 或者 `hash` 了

