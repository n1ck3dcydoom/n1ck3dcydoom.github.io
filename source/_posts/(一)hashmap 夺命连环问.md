---
title: (一)hashmap 夺命连环问
date: 2022-11-16 14:44:12
index_img: /img/java.png
categories:
  - jvm
tags:
  - jvm
---

### 底层数据结构

1. jdk 1.7 及以前采用 `数组` + `链表`
2. jdk 1.8 及以后采用 `数组` + `红黑树`

### 为什么选用红黑树

对于查找性能来说,链表的时间复杂度是 `O(n)` 而红黑树的平均查找时间复杂度为 `O(logn)`

### 什么时候是链表,什么时候选用红黑树

当链表节点个数超过 8 个以后,如果总节点个数超过 64 个,会变为 `红黑树`; 如果不足 64 个,此时会触发扩容操作

### 为什么回转节点个数为 6 而不是 8

如果说超过 8 个就将链表转化为红黑树,小于 8 个就将红黑树退化为链表; 如果节点个数在 8 个上下反复发生变化,此时的转化开销非常大,严重影响 `hashmap` 的性能

所以将回转节点的个数设置为 6 个就是为了避免反复转化

### 为什么转为红黑树的条件是节点个数大于 8 个,而不是其他数字

因为红黑树节点个数小于 8 个的时候,其查找性能与链表差不多,体现不出红黑树的优势; 而且一个红黑树节点要保存的信息远比链表节点多,差不多在 2 倍左右,在小于 8 个节点的时候,查找性能相差无几但是要付出 2 倍的空间消耗,这是不划算的

### hashmap 的关键属性有哪些

1. size: 保存了键值对的个数
2. threshold: 扩容阈值,当 size 达到 threshold 时,触发 `hashmap` 的扩容机制
3. loadFactory: 负载因子,默认值为 `0.75`

### threshold 除了是扩容阈值以外还有什么作用

`threshold` 会在初始化之前保存默认的大小 16,为了不必要的空间浪费, `hashmap` 会在第一次插入数据的时候才进行初始化,在这之前都是空的

### hashmap 如何计算每次扩容后的大小

```
static final int tableSizeFor(int cap) {
    int n = cap - 1;
    n |= n >>> 1;
    n |= n>>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
}
```

如何理解,明确一点计算新的大小,其实就是为了找到下一个 2 的 n 次幂,而 2 的次方在二进制表示里面只有 1 个 1,所以算法就是为了找到这个 1 的位置

首先跳过第一行的 `cap - 1`,假如输入的 n 二进制表达把首位的 1 留下,其他低位全部用 x 表示忽略,即 `1xxxxxxxxx`

向右无符号移动 1 位得到 `01xxxxxx` 和原来的 n 值做 `|` 或运算,其效果相当于给前 2 位赋值 1,即 `n = 011xxxxxxxxx`

同理向右无符号 2 位得到 `00011xxxxxxx` 和原来的 n 值继续做或运算,相当于给前 4 位赋值 1,即 `n = 0001111xxxxxxxx`

重复移位 4 次,得到的结果是前 8 位全部为 1; 重复移位 8 次,得到的结果是前 16 位全部为 1; 重复移位 16 次,得到的结果是前 32 位全部为 1

这里 1 的个数取决于输入的 n,当某次移位超过 n 原来的 1 之后,在做或运算也不会有影响了

经过 5 步运算后,会得到一个高位全是 0,低位全是 1,并且大于 n 的数,最后 `n+1` 就会返回一个 2 的幂次并且是大于 n 的下一个 2 的幂

回到第一行 `cap - 1` 则是为了防止 cap 本身就已经是 2 的幂次的情况

### 计算 key 在数组当中的位置如何确定的

```
index = (n - 1) & hash
```

当 n 是 2 的幂次时,上述计算结果等于 `index = hash % n` 而且位运算的效率远高于取模运算 `%`

### 插入元素时如何计算 hash 值

```
static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
```

取 `key` 的 `hashCode` 向右移 16 位和做异或运算

为什么要和高 16 位做异或运算?

考虑到计算 hash 数组位置的公式 `(n - 1) & hash`, 如果 n 值很小,例如只有 4 的时候, `n - 1` 仅仅只有 3 位,此时 hash 值只有第三位参与了运算

这增大了 hash 冲突的概率,而让高 16 位于低位进行异或运算后,右移补充的 0 异或运算结果不变,此时高 16 位与低 16 位的异或运算会进一步打乱低位的值

这样的做法就是为了避免 n 值较小的时候,发生 hash 冲突的概率

### hashmap 的扩容过程

扩容时,会创建一个原来数组容量一倍的新数组,并将原来数组中的值重新计算 hash 值后插入新的数组

因为容量永远是 2 的幂次,对于一个 `key` 重新通过 `(n - 1) & hash` 过后,这里的 `(n - 1)` 比扩容前的 `(n - 1)` 首位多了个 1 出来

这时如果 `key` 的哈希值在这个多出来的位也是 1,那么新的位置就是原来位置 + 扩容 n 过后的值; 如果多出来的位是 0,则位置不变

这样在做扩容的时候,就可以把原来可能产生 hash 冲突的的 `key` 再次放到不同的哈希桶里了

![img.png](https://tva1.sinaimg.cn/large/008vK57jgy1h87u14p6tqj30q307haej.jpg)

### 扩容过程 1.7 和 1.8 的差异

1.7 在扩容的时候采用头插法

1.8 在扩容的时候采用尾插法,避免了链表出现环的问题

例如线程 A 插入节点 B,线程 B 插入节点 A,当线程 A 完成插入后触发 `rehash` 此时线程 B 需要重新放置节点 B 的位置,根据头插法则产生了环

![img_1.png](https://tva1.sinaimg.cn/large/008vK57jgy1h87u1e6fzqj30is0biaea.jpg)

### 线程安全的 map 集合

1. HashTable 线程安全,对整个 hash 数组加锁,并发度低
2. ConcurrentHashMap 线程安全,对单个哈希桶加锁,并发度相对较高

![img_2.png](https://tva1.sinaimg.cn/large/008vK57jgy1h87u19lr96j30ke0dgjy5.jpg)

`ConcurrentHashMap` 的 `CAS` 操作

当初始化哈希桶的时候,此时的并发安全由 `CAS` 提供

![img_3.png](https://tva1.sinaimg.cn/large/008vK57jgy1h87u1iswolj30hb02jwg9.jpg)