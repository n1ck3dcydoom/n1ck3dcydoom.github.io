---
title: (五)mysql 锁
date: 2022-11-04 16:41:17
index_img: /img/mysql.png
categories:
  - mysql
tags:
  - mysql
---

## 锁

锁是用来保证事务并发,数据安全的一种手段

mysql 有三种类型(注意:是 **三种类型** 而非 **三种**):

1. 全局锁
2. 表级锁
3. 行级锁

### 全局锁

全局锁就是对 **整个数据库实例** 加锁,在此期间,整个数据库处于 **只读** 状态,除了读其他所有操作都会被拒绝

全局锁的作用几乎都是用来做 **整库备份**, 如果在做整库备份的时候,没有加上全局锁,这个时候表仍然可以写,就会出现备份前后数据不一致的情况

在事务里面,mysql 通过 `MVCC` 多版本并发控制来保证事务的隔离性,用到的数据结构是 `视图`,这个视图保证了在启动事务的时候,是处于一个 **静止状态的逻辑时间点**

参考事务,在做全局备份的时候,也生成一张视图,这样后续的读写请求都不会因为全局锁而阻塞; 既然有视图的存在,为何备份的时候还需要全局锁呢

考虑到有些存储引擎, 例如 `Myisam`, 它不支持事务; 这样在备份的时候仍然能取到最新的数据,破坏了数据的一致性

还有一种方式也能够实现类似于 **全局锁** 的能力,那就是 **将数据库设置为只读状态**

```sql
set global readonly = true
```

但是仍然不建议使用将数据库设置为只读状态来进行整库备份

1. 客户端连接数据库实例后,加上全局锁进行备份,如果中间发生异常导致客户端断开连接,这个时候数据库也能将全局锁自动恢复,以保证数据库实例能够继续对外提供服务
2. 如果是通过设置只读的状态,如果连接在中途断开后,数据库是不会从只读状态中恢复的,此时会导致整个数据库对外停止服务
3. 有些数据库框架可能会用 `readonly` 字段做业务逻辑,例如判断是否是主库,是否是从库; 改变这个值可能会引起主从判断的逻辑

### 表级锁

表级锁有两种:

1. 表锁
2. 元数据锁

#### 表锁

表锁的使用限制非常严格,例如

```sql
lock tables t1 read, t2 write
```

如果线程 A 在某个时刻执行上述语句后, 其他线程写 t1 ,读写 t2 的请求都会被阻塞,这个很好理解

但是对于线程 A 来说,就更加严格,它只能够读取 t1,连写 t1 都不行; 对于 t2 来说,线程 A 能够读写; 而且线程 A 也不能访问其他表

#### MDL 元数据锁

`MDL` 锁是不需要显式声明的,在访问一张表的时候,数据库会自动为这张表加上 `MDL` 锁

简单来说, `MDL` 锁是为了保障表结构的完整性不受到影响

例如当一个线程正在查询表 A 里面的 c1,c2,c3 三列数据列,此时另外一个线程却对表 A 执行了一条 `alter` 语句,结果是删掉了 c3 列

这就导致原来的线程在获取道德数据跟原来的表结构不一致了

mysql 引入了 `MDL` 锁,分为 `MDL`读和写两种子类型:

* 读锁之间互不影响,也就是说对于同一张表, 每个线程都可以持有对应的 `MDL` 读锁,所以每个线程之间的读请求互不受到影响
* 写锁之间和读写锁之间互斥, 一旦有一个线程正在修改表结构,此时其他所有的读请求和写请求都会被阻塞掉,只有等待写锁释放后,才能进行后面的操作

介绍一个由 `MDL` 锁导致的故障问题,假设有如下 4 个会话执行顺序如下:

![img.png](https://tva1.sinaimg.cn/large/008vK57jgy1h7tgl1480lj30j30bvdih.jpg)

会话 A,B 分别执行查询语句,申请 `MDL` 读锁,这没问题; 会话 C 执行 `alert` 语句申请 `MDL` 写锁,此时阻塞

问题来了,如果仅仅是会话 C 阻塞还好,可如果后面还有其他请求进来访问表,都会被会话 C 阻塞掉

为什么说会话 C 申请写锁被阻塞之后,还会继续阻塞其他读写锁的申请呢

mysql 在内部使用 **优先队列** 来维护所有的 `MDL` 锁申请,而且,而且 **写锁的申请优先级高于读锁**

这就解释了为什么会话 C 的写锁申请阻塞,会导致后续的读写锁申请都被阻塞: **因为有一个高优先级的申请在前面,所以队列后面的请求只能一直等待即使有相同的优先级**

### 行级锁

`MDL` 锁是有 `Server` 层提供的能力,而行级锁是由存储引擎提供的能力,有些例如 `Myisa` 就不支持行级锁

#### 两阶段锁

**先说结论: 在 InnoDB 事务当中,行锁是在需要的时候才加上,而要等到事务提交后才释放锁, 这个叫做两阶段锁协议**

起作用就是,当事务需要持有多把锁时,要尽可能把最可能影响并发度的锁放到后面

举个简单的例子:

1. 客户使用账户 A 购买商家的东西,要在账户 A 上扣款
2. 商家使用账户 B 进行收款
3. 商家记录一笔交易记录

可以看到上面的三步操作肯定是在一个事务里面执行,其中 1,2 分别是 `update` 操作,3 是 `insert` 操作,且 3 和 1,2 之前没有先后依赖关系

如果这个时候有另外一个客户也在商家这里购买东西,那么这也是 `update` 操作,且和前面的 1,2 步骤 `update` 的是同一个账户

为了使都操作账户 B 带来的并发等待最小,第一个客户应当对步骤进行重新排序,例如 3,1,2 这样把存在锁竞争的步骤 2 放到了最后面,这样第一个客户持有账户 B 的锁时间被降低到了最短,尽可能地降低锁导致的并发问题的影响

#### 死锁

什么是死锁: 当并发系统中几个线程出现 **循环等待** 资源,涉及到的线程都在等待别人释放自己需要的资源,且 **一直等待** 下去的现象,称为死锁

死锁发生的 3 个必要条件:
1. 互斥条件:一个资源只能被一个线程使用,其他线程只能等待释放
2. 请求和保持:一个线程请求其他互斥资源时,不会释放自己手里的资源
3. 不可抢占:线程不能强行从其他线程那里获取自己需要的资源,只能等待其释放
4. 循环等待:存在循环链,使得每个线程都在等待别人释放自己需要的资源

![img_1.png](https://tva1.sinaimg.cn/large/008vK57jgy1h7tgkpg18ij30jh0c6juh.jpg)

可以看到事务 A 启动后申请对 id=1 的资源的锁,事务 B 启动后申请对 id=2 的资源的锁

然后事务 A 申请 id=2 的锁,发现被事务 B 持有,此时事务 A 阻塞等待事务 B 释放 id=2 的锁

接着事务 B 申请 id=1 的锁,发现被事务 A 持有,此时事务 B 阻塞等待事务 A 释放 id=1 的锁

这样两个事务都在等待对方释放自己的资源,进入死锁状态

#### mysql 如何解决死锁

1. 超时等待

mysql 有个超时等待时间,默认值为 50s,意味着一个线程进入等待后 50s 没有拿到资源,就放弃等待

50s 的等待时长一般难以接受,太小的话容易误伤正常的锁等待,所以这个策略很少使用

2. 主动死锁检测

当一个事务发生等待时,会主动检测事务所依赖的所有线程是否有被其他线程锁住,以此循环下去最后判断是否出现了死锁

主动死锁检测虽然可以发现死锁,但是也存在性能问题

假如有 100 个线程同时更新 1 个资源,第一个拿到锁的线程开始处理,后面每个进来的新线程都要等待第一个线程释放锁,每个线程都要做一次死锁检测,而每次都会循环检查其他的线程,相当于最后产生了 10000 次死锁检查

最终的检测结果是没有发生死锁,但是这个过程却是相当耗费 cpu 资源的

#### 如何减少主动死锁检测带来的 cpu 性能消耗问题

对于这种 **热点数据** 的并发更新,死锁检测往往会占用大量的 cpu 资源

1. 从源头上控制,假如能够限制客户端的并发,例如一个客户端发起 5 个链接,那么死锁检测的成本就很低能够接受

但是难以避免出现大量客户端发起连接更新热点数据,即使单个客户端的并发数很小,但是客户端数量过多仍然会导致死锁检测耗费大量 cpu 资源

2. 在业务上做出拆分,将原来一整块的并发资源,拆分为多个子集

例如原来的一个账户,拆分为 100 个账户的总和,每次更新总账户的时候,实际上是随机更新一个子账户

这样可以将一个资源面临的大量访问均分到多个资源上,减少单个资源的并发度,降低死锁检测的 cpu 消耗

但是这样要考虑如何汇总零散的资源,以及单个资源的上出现的特殊情况,这样的做法会导致业务的复杂程度变高