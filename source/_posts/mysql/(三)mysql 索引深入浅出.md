---
title: (三)mysql 索引深入浅出
date: 2022-11-03 22:31:40
index_img: /img/mysql.png
categories:
  - mysql
tags:
  - mysql
---

## mysql 的索引

### 索引数据结构的发展

索引是一种数据结构,用来提高查询效率,常见的用于提高查询效率的数据结构大致可分为以下三种

1. hash
2. 有序数组
3. 搜索树

#### hash

hash 表提供一种 `k-v` 的关系,当输入 `key` 值,可以在 `O(1)` 的时间复杂度内返回对应的 `value` 值

但是 hash 表本身是无序的,也就是说对于确定的 **等值** 查询,即检索在不在,有没有这种情况来说,hash 表能够胜任

但是对于范围查询,hash 表的性能表现就会非常差,因为 hash 表无法确定数据的范围,所以在对范围查询时,需要遍历整个 hash 表

#### 有序数组

有序数组的结构本身也很简单,他对范围查询提供很好的性能表现,对于等值查询,则可以借助有序的特点,使用 `二分查找` 提高查找效率

但是数组的问题就在于对于元素的删除和增加操作非常麻烦,通常需要大批量连续移动若干个节点,才能保证数组的数据结构不被破坏

如果采用有序链表,虽然能够提高插入和删除操作,但代价就是失去了随机访问的能力,对于 **等值查询** 链表则需要遍历所有节点

#### 搜索树

对于二叉搜索树来说,每个左孩子都小于父节点,每个右孩子都大于父节点,可以看做是二分查找的运用,其搜索一个节点是否存在的时间复杂度是 `O(logn)`

考虑最极端的情况,如果所有节点都只有左孩子,那么整棵树将退化成一条链表,此时时间复杂度退化为 `O(n)`

所以为了平衡这些极端情况,维持 `O(logn)` 的时间复杂度,需要树能够做出自平衡,所谓平衡就是说树中每个节点的左子树和右子树的深度之差不超过 1

这种具有自平衡的二叉搜索树叫做 `AVL` 树

但是数据库也放弃使用 `AVL` 树当做索引,原因如下:

`AVL` 树是一棵 **二叉树** ,每个节点只能保存两个孩子节点,如果说数据量过大,那么二叉树的深度将会变得非常深

索引数据并非只存在于内存里,还需要保存到磁盘上;每个节点在磁盘上的位置并不是连续的,如果对于非常靠近叶子节点的位置,其搜索次数能够轻松达到几十上百次

这样就会导致几十上百次磁盘的访问,整体的检索性能会严重被树深影响

#### B 树

为了解决 `AVL` 树二叉导致磁盘访问频繁的问题,引入 **N 叉树** 的概念

根据经验, innoDB 里面的 `N` 大概在 1200 左右,对于一棵树深高度为 3 的 N 叉树,其能够保存接近 17 亿的数据

这样查询一个节点,其最多也就访问 3 次磁盘而已,极大地减少了对磁盘的访问

B 树在普通 N 叉树的基础上,会在节点里面同时保存数据,也就是说一个 B 树的节点不仅仅会保存索引值,还会保存对应的数据

这就导致了空间的浪费,也会拖慢检索速度,举个简单的例子说明,假说一个节点值保存 8k 的内容

如果节点里面的数据占用了 3k,那么剩下的索引值就只有 5k,如果本可以通过一次查询得到的索引值,由于节点上保存了数据,导致需要多次查询才能得到对应的索引值

至此 mysql 索引的终极解决方案 B+ 树横空出世

#### B+ 树

B+ 树在 B 树的基础上,将中间节点保存的数据全部移除,这样中间节点就只负责保存索引值

所有的数据都落到叶子节点上,这样每次查询的次数都是相同的,提高了查询的稳定性

对于 B 树来说,有些数据可能在根节点,有些数据可能在叶子节点,不同的查询可能根据位置不同有较大的差异

B+ 树的叶子节点按照关键字,从小到大顺序排列,并且通过前驱和后继两个指针,构成一个 **双向链表**

由于是有序排列,所以 B+ 树也能够应对范围查询

对比 B 树,B+ 树的优点如下:

1. 由于数据按照双向链表有序组织,区间查询的性能比 B 树高
2. 所有数据分布在叶子节点上,每次查询的次数相等,稳定性比 B 树高
3. 遍历所有数据时,只需要遍历叶子节点下面的双向链表即可,不用扫描整棵树,而 B 树需要扫描整棵树

#### B* 树

B* 树是在 B+ 树的基础上,更进一步

B+ 树在插入和删除节点时,分裂与合并节点带来性能开销,为了减少节点的操作次数,B* 树在每个非叶子节点上保存了相邻兄弟节点的指针

同时在初始化节点中关键字数量上,由 B+ 树的 `ceil(m/2)` 改为 `ciel(2m/3)`

当某个节点的关键字个数达到 `2m/3` 时,会查询相邻兄弟节点之间是否还有空余,如有的话则插入关键字向兄弟节点转移,减少了节点的分裂次数

### 聚簇索引和非聚簇索引

假设当前表里存在一个主键列 id,和一个字段列 k,同时对于字段列 k 建立索引

此时表的索引结构如下:

![img.png](https://tva1.sinaimg.cn/large/008vK57jgy1h7scjjearwj30k708hdie.jpg)

可以看到,对于主键列的索引,叶子节点保存的内容为 `id - 数据` ,而对于非主键索引 k 来说,里面记录的内容为 `k - id`

根据索引的叶子节点保存的东西不同,可以把索引分为两大类

1. 聚簇索引: 保存数据的索引
2. 非聚簇索引: 保存主键的索引

对于 **聚簇索引和非聚簇索引,其检索有何区别**

简单来说,在聚簇索引上的查询,只需要通过查找主键 id 就可以得到具体的数据,一次索引树的访问即可

而非聚簇索引上的查询,则必须要先通过字段列查找到主键 id,然后再通过主键 id 去查找对应的数据,需要 2 次索引树的访问

对于非聚簇索引上的第二次查找主键 id 的过程,称为 **回表**

由于回表多了一次索引树的查找,所以尽可能使用聚簇索引来完成数据检索

### 覆盖索引

假设存在如下 sql 语句,会执行多少次查询

```sql
select * from table where k between 3 and 5
```

1. 从非聚簇索引 k 里面查找到 k=3 的记录,得到主键 id=300
2. 从聚簇索引里面查找到主键 id=300 的记录,得到数据 R3 返回
3. 继续遍历 k=3 的下一个数据,k=5,得到主键 id=500
4. 从聚簇索引里面查找到主键 id=500 的记录,得到数据 R4 返回
5. 继续遍历 k=5 的下一个数据,k=6,不在查询范围内,结束

由上一节可知,通过非聚簇索引查询聚簇索引的现象称为 **回表**

上面 5 个查询过程当中,2,4 发生 **回表** 查询,1,3,5 在索引列 k 上发生普通查询

由于索引列 k 里面的数据只记录了主键 id,并不包含 `select` 语句后面 `*` 里面的所有数据

所以不得不通过 **回表** 查询主键索引得到完整的数据

假如我们的 sql 发生一点小小的改动

```sql
select k from table where k between 3 and 5
```

此时 `select` 语句后面只需要查询 `k` 字段列即可,通过在 k 上面的普通索引,已经包含查询的所有信息了,此时无需再回表查询其他数据

这种 **索引列 k 已经覆盖查询请求** 的现象,称为 **覆盖索引**

**覆盖索引能够有效的减少回表查询的次数,因此是一种提升性能的常用手段**

*存储引擎和 Server 层的数据扫描统计*

需要注意的是,在上面 **覆盖索引** 的查询过程当中

存储引擎实际扫描了 3 次,即 k=3,=5,=6 然后返回数据 k=3 和 k=5

而对于 Serve 层来说,它只从存储引擎哪里拿到了 2 条记录,所以 Server 层认为实际扫描行数只有 2 条

#### 联合索引通过覆盖索引来提高查询效率

考虑如下场景,对于每个学生来说,都有 `学号`, `姓名`, `年龄`,

通常来说,通过 `学号` 已经能够唯一定位到一个学生,因此一般都选择在 `学号` 上建立主键索引

在 `姓名` 上,也创建普通索引

此时查询所有姓张的同学的 `姓名` 和 `年龄`

```sql
select name, age from students where name like '张%'
```

此时是能通过 `姓名` 的索引找到所有姓张的主键 id,在通过主键 id 得到完整的数据行,最后取出 `姓名` 和 `年龄` 返回结果

若存在大量的这种查询,则 **回表** 会明显的拖慢查询的性能

若在 `姓名` 和 `年龄` 上建立联合索引 `name_age` 则查询就会变为在索引 `name_age` 里面查找姓张的同学和年龄,而索引 `name_age` 正好又包含了查询所需要的数据,此时就不用发生 **回表** 查询

这样的联合索引,通过 **覆盖索引** 实现了性能的优化和提升

#### 联合索引的 "最左匹配原则" 和 "最左前缀原则"

**定义:在联合索引列上,从左左侧的字段开始一直向右匹配索引,直到遇到范围查询(>,<,between,like),此时停止对后面的索引列的匹配**

**定义:最左匹配原则同样也满足最左前缀原则**

即对于索引 `name, age` 来说, 查询 `name like ('张%)` 也能够用上索引

但是对于如下查询 `name like (%三)` 此时联合索引左侧的索引列 `name` 的查询条件前缀是不确定的 `%` 通配符,此时会导致 **最左前缀原则** 失效,从而导致 **索引失效**

假如有联合索引 `(a,b,c,d)`

```sql
select * from t where a > 3 and b = 4 and c = 5
select * from t where a like 'h%' and b = '123' and c = '456'
```

这里联合索引的顺序为 a>b>c>d,所以 `where` 语句从 `a` 开始从左往右查找是否有索引列匹配

`a > 3` 和 `a like 'h%'` 都是范围查询,所以根据定义可知,后面的索引列就不再匹配

所以以上 2 条 sql 只有 `a` 用上了索引, `b` 和 `c` 都没有用上索引

```sql
select * from t where a = 1                        // a
select * from t where a = 1 and b = 2              // a,b
select * from t where a = 1 and b = 2 and c = 3    // a,b,c
select * from t where a = 1 and c = 3              // a
select * from t where b = 2                        // nothing
select * from t where b = 2 and c = 3              // nothing
```

特殊情况

```sql
select * from t where b = 2 and a = 1              // a,b
select * from t where a = 1 and c = 3 and b = 2    // a,b,c
```

上面 2 条 sql 语句,mysql 的优化器会自动调整字段的位置,从而使用上联合索引加快查询速度

**总结**

根据 **空间** 来决定是否需要在联合索引上,为那些不满足 **最左匹配原则** 的字段列再次单独建立联合索引或者单独的索引

即是否又需要建立 `(b,d)` 或者 `(c)` 这样的联合索引或者单独索引,这取决于查询的频率以及是否满足 **覆盖索引** 来优化查询

### 索引下沉(也称为索引下推)

对于那些不满足 **最左匹配原则** 的查询,用不上索引的字段列究竟如何完成检索

考虑如下 sql ,同时有联合索引 `(name, age)`

```sql
select * from students where name like '张%' and age = 15
```

根据 **最左匹配原则** 可以用到 `name` 这个索引,因为 `name` 后面有 `like` 语句,表明这是一个范围查询,所以后面的索引列停止匹配

此时假设存在以下数据:

![img_1.png](https://tva1.sinaimg.cn/large/008vK57jgy1h7scjt909lj30lj07v41k.jpg)

* 在 mysql 5.6 版本以前,这样的查询只能通过在联合索引 `(name, age)` 上,通过 `name` 检索到第一个姓张的同学,得到对应的主键 id,然后回表查询对应的数据行,最后取出 `age` 字段返回结果集; 接着就是从 `name` 索引上依次遍历符合条件的主键 id,然后依次回表查询得到最终的完整数据

可以看到的就是,每次查询都存在一个与之对应的回表操作,这无疑降低了查询的性能

* 在 mysql 5.6 及以后的版本中,添加了一个新特性 **索引下沉**

**定义:将本来应该在 Server 层进行的过滤操作,下沉到存储引擎层完成; 在遍历索引的过程当中,预先过滤掉不满足索引条件的记录行,减少回表的次数**

![img_2.png](https://tva1.sinaimg.cn/large/008vK57jgy1h7sck49cfpj30lp07zn0d.jpg)

如果不使用索引下沉优化,则存储引擎只会根据索引 `name` 查找到所有姓张的同学,并依次回表查询到完整数据行返回给 Server 层

然后在 Server 层对结果集做 `age = 15` 的判断,筛选出满足查询条件的结果集

而对于使用索引下沉的优化来说,在检索联合索引 `(name,age)` 的时候,存储引擎就预先将 `age` 不满足条件的记录过滤掉; 将本来在 Server 层做的操作下沉到存储引擎层

这样最终需要回表的操作就只有 2 次了,减少了回表的次数,提高查询的性能

**索引下沉的条件,索引列中包含有待查询的字段,这样可以提前放到存储引擎来判断索引条件是否满足查询条件**

如果查询的是 `name` 和 `gender` ,由于索引列里面不包含 `gender` 即使将 `gender = 1`下沉到存储引擎,也无法通过覆盖索引得到 `gender` 值,还是需要依次回表查询才行

此时就失去了索引下沉的优化