---
title: (八)mysql count 函数机制
date: 2022-11-05 15:52:17
index_img: /img/mysql.png
categories:
  - mysql
tags:
  - mysql
---

### count(*) 的实现原理

1. 在 `Myisam` 上,每个表的总行数保存在了磁盘上,因此 `count(*)` 可以在 O(1) 的时间复杂度之内得到,效率非常高
2. 在 `InnoDB` 上,不会单独保存表的总行数,因此只能通过遍历所有数据,完成统计得到

为什么 `InnoDB` 不保存总记录数,因为 `MVCC` 多版本并发控制导致,即使每次执行 `count(*)` 语句时,快照读返回的行数都不一定是准确的

例如事务 A 快照读的时候得到行数 10000,在这个过程中事务 B 插入了 1 行,因为快照读的原因事务 A 并不能观察到这 1 行,所以返回的行数并不准确

![img.png](https://tva1.sinaimg.cn/large/008vK57jgy1h7ubro5pldj30ne08yjuu.jpg)

具体 mysql 是怎么实现 `count(*)` 的计算过程呢

由于只能一行一行地遍历所有数据,那么就需要从索引树的叶子节点的链表开始遍历; 前面说过,聚簇索引的叶子节点保存的是 `主键 id 和完整数据行`; 而非聚簇索引的叶子节点保存的是 `索引列和主键 id`; 这样对于相同大小的页,后者能够放下更多的节点

因此 myslq 实际上在做 `count(*)` 的时候,会选择最小的索引树进行遍历,加快遍历的速度

### 使用缓存系统保存总数

如果有个业务需要频繁的访问表的总记录数,而数据又非常多,那么 `count(*)` 势必导致性能问题

考虑设计一个缓存系统来保存总数,每次增删记录的时候,同时更新缓存里面的总数

实际上并不能通过 redis 来完成这个缓存系统,因为总是存在数据不一致,有点类似幻读的感觉,例如下面两个例子

![img_1.png](https://tva1.sinaimg.cn/large/008vK57jgy1h7ubru7q69j30nc08yaay.jpg)

实际上会话 B 在查询最近 100 条记录的时候,会把会话 A 插入的新数据查询出来,但是会话 B 访问 redis 的时候总计数却不包含这一条,因为此时会话 A 还没来得及更新 redis

如果反过来

![img_2.png](https://tva1.sinaimg.cn/large/008vK57jgy1h7ubrzdpldj30n809pt9j.jpg)

会导致会话 B 从 redis 里面已经得到的总数已经新增了一条,但是最近 100 条记录里面却不包含这新增的一条,再次发生数据不一致的问题

这些都是因为缓存系统无法完全保证数据实时一致性,考虑使用数据库当做缓存系统使用

将对 redis 的操作更换为数据库操作,同时为其加上事务

![img_3.png](https://tva1.sinaimg.cn/large/008vK57jgy1h7ubs4hin0j30n50ci0ts.jpg)

根据 `MVCC` 会话 B 读到的总数并不包含会话 A 新增的总数,而且前 100 条记录也不包含回话 A 新增的数据; 这是由 `MVCC` 的快照读保证的一致性

### 不同的 count 函数使用方式

不仅仅有 `count(*)` 能够统计行数,还有 `count(1)`, `count(主键)`, `count(字段)` 等等

其原理都差不多,`count()` 本身是一个聚合函数,起作用就是对于返回的结果集进行遍历,如果参数不是 `NULL` 就将结果值+1,所以上面那么多不同的 `count()` 操作,其本质就是在计算返回的结果集对应的参数不是 `NULL` 的总数

记住以下原则 `Server` 层要什么,存储引擎就给什么

* `count(主键)` 存储引擎遍历整张表,把每一行的主键 `id` 取出来返回给 `Server` 层将,然后 `Server` 判断是否为 `NULL` 并计数
* `count(1)` 存储引擎遍历整张表,但是不取具体值,而是对每一行返回一个 1,由 `Server` 层判断是否为 `NULL` 并计数
* `count(字段)` 如果这个字段定义为 `NOT NULL` 非空的话,原理同 `count(主键)`; 如果定义允许 `NULL`,则需要对每一行判断是否为 `NULL` 后计数
* `count(*)` 优化器做了专门的优化,不会取所有值

从性能层面来说 : `count(*) ≈ count(1) > count(主键) > count(字段)`