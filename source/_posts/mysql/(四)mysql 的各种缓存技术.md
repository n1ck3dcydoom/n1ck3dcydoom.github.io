---
title: (四)mysql 的各种缓存技术
date: 2022-11-03 23:18:25
index_img: /img/mysql.png
categories:
  - mysql
tags:
  - mysql
---

### 预读 局部性原理

操作系统有个很经典的理论,叫做 **局部性原理** ,意思就是说如果使用了一些数据,那么大概率接下来还会使用这些数据附近的其他数据

同时,磁盘的读写并不是按需读取,也就是说并不是需要什么数据就读取什么数据; 而是按照一定大小的页,一次性读取到内存当中,通常这个页的大小默认为 `4K`

因为根据局部性原理,访问了数据 x 之后,大概率还会访问 x 附近的其他数据; 而如果是按需读取的话,在访问 x 之后,继续访问 y 和 z 又要进行磁盘操作,这无疑增大了 io 的消耗

对于按页读取 ,可以一次性将 x 所在的那一页都放到内存里,这样以后再访问 y 或者 z,就可以直接从内存里读取,无需磁盘操作

可能有疑问就是,如果 x 正好在当前页的最后一条记录,那么访问 y 或者 z 必然要再读取下一页; 实际上这种情况发生的概率非常小,即使如此,再读取下一页也比每次都访问磁盘的效率高得多,是值得接受的必要 io 消耗

mysql 为了利用磁盘按页读取的能力,在其内存缓存池里面,也是按照页为单位来加载磁盘上的数据

### mysql 如何管理缓存 读缓存(buffer pool)

管理缓存有个非常经典的算法, `LRU` 最近最少使用算法

最常见的实现就是通过一个固定大小的双向链表,将最近一次访问的页放到链表头,这样链尾上的最长时间没有使用的页就会被淘汰置换出链表

`LRU` 在更新内存页的时候,又分为两种情况

* 当前命中的页已经在缓存里面了,这时只需要把命中页置换到头部即可
* 当前命中的页还不在缓存里面,这时需要通过一次磁盘 io 把磁盘页读取出来放到缓存头部

对于一个已经装满的缓存,第一种情况只会发生置换页的操作,不会有页被淘汰;第二种情况则是会淘汰尾部的最后一页

朴素 `LRU` 在很多内存缓存里面,例如 `MemoryCache` 运用的很多,但是 mysql 并没有选择朴素 `LRU` 算法,这是因为有以下两个问题

1. 预读失效
2. 缓存污染

#### 预读失效

由于 mysql 预读将部分磁盘页放到缓存里面,但是因为某些原因,这些预读出来的页并没有实际访问到,导致预读失效

假设缓存大小等于 `10 ,且磁盘页 `50` 被预读放入缓存,考虑如下情况

![img.png](https://tva1.sinaimg.cn/large/008vK57jgy1h7t6j8tn3ij30an02maa7.jpg)

此时预读出来的页 `50` 被放到缓存头部,但是后续再也没有发生过对 `50` 的访问,这导致预读出来的数据 `50` 需要被置换 10 次后才能够被淘汰掉

这使得这些未命中的预读页,在缓存里面的停留时间过长

mysql 采用 **改良的 LRU 算法** ,将普通缓存改为 **分代** 设计,分为 **新生代** 和 **老年代**

![img_1.png](https://tva1.sinaimg.cn/large/008vK57jgy1h7t6jirxpjj30b504lmxj.jpg)

* 缓存被分为两个部分 **新生代** 和 **老年代**
* 实际上是通过 4 个指针,分别维护新生代头尾和老年代头尾
* 新页在放入缓存的时候,首先放入 **老年代**
* 如果 **老年代** 里面的页发生了命中,才会加入 **新生代**
* 如果 **老年代** 里面的页没有发生命中,那么在 **更短的时间内** 它将被移除缓存

这样使得那些被预读放入缓存,但是又长时间没被使用过的页,能够尽快的从老年代里面淘汰出去

#### 缓存污染

什么是缓存污染: **当 mysql 发生大面积扫描数据行的时候,会将大量数据页放入缓存后,立马又再次换入新的数据页; 导致每页只在缓存里面停留非常短的时间就被置换出去**

缓存污染将会显著导致 mysql 的性能下降

例如一次全表扫描时:

1. 将预读页放入老年代
2. 从老年代里面访问页加入新生代
3. 下一次预读又会将全新的页刷入老年代
4. 重复 123 步骤,直到完成全表扫描

可以看到在这样的场景下,所有的页都被放入缓存 1 次后,立马又被新的页置换掉; 从而导致原本缓存里面真正的 **热数据** 被大量新页挤出缓存,从而导致 mysql 的性能下降

mysql 为了解决缓存污染问题,引入了 **老年代停留窗口** 的概念

放入老年代后,如果再次命中,并不会立即放入新生代,而是要求在老年代待满多少时间后才允许进入新生代

![img_2.png](https://tva1.sinaimg.cn/large/008vK57jgy1h7t6joyl78j30ci082js4.jpg)

假设有大量需要扫描的页需要进入缓存,此时首先进入的是老年代

![img_3.png](https://tva1.sinaimg.cn/large/008vK57jgy1h7t6k1gfkzj30hw05fq47.jpg)

如果老年代里面装不下,即使页被访问了,也会被缓存淘汰掉

这个时候缓存头部的那些高频命中的新生代热点数据,不会立马被这种大批量扫描的页给置换出去

对于能够命中新生代的查询来说,此时缓存依然能够提供服务,并且性能依旧高效

而对于老年代里面的页,命中后需要判断是否满足 **老年代停留窗口** 的时长 `T`

* 如果 `停留时长 >= T`,则将其置换到新生代的头部,此时新生代的尾部页面会进入老年代作为的老年代的头部
* 如果 `停留时长 < T`,则只会将其置换到老年代的头部,不会进入新生代

### mysql 如何管理写缓存 (change buffer)

简单回顾下读缓存在 mysql 保存了什么内容

1. 索引页
2. 索引页对应的数据页

对于读请求,`buffer pool` 通过改进后的 `LRU` 算法实现缓存管理,解决 `预读失效` 和 `缓存污染` 的问题

对于写请求,究竟该如何管理缓存呢,以几个例子分别分析下

#### 写的页正好在 buffer pool 里

![img_4.png](https://tva1.sinaimg.cn/large/008vK57jgy1h7t6ju3go6j308p072gmf.jpg)

1. 直接在页上写入数据
2. 然后写入 `redo log` 

是否会出现一致性问题呢: **不会**

1. 读取,会命中缓存池的页
2. 缓存池 `LRU` 数据淘汰,会将 `脏页` 刷回磁盘
3. 数据库宕机,能够从 `redo log` 中恢复数据

#### 写的页不在 buffer pool 里

![img_5.png](https://tva1.sinaimg.cn/large/008vK57jgy1h7t6kjgoolj308j06vaaw.jpg)

1. 一次随机磁盘访问,将需要写入的页加载到缓存池里
2. 在缓存池里写入数据
3. 写入 `redo log`

由于写入页不在缓存池里,多了一次从磁盘读取对应页的操作,mysql 为了减少这一次磁盘操作,引入了写缓存 `change buffer` 的概念

**定义:当对一张不在缓存池里且 `非唯一索引` 的页进行写入操作是时,并不会立即从磁盘里加载对应的页,而是通过在写缓存 `change buffer` 里 `记录` 当前操作,直到后面需要访问这张页的时候,在进行合并 `merge` 操作**

这样对流程上来说带来的改变如下:

![img_6.png](https://tva1.sinaimg.cn/large/008vK57jgy1h7t6kq2mdfj30bf06xmya.jpg)

1. 没有立即从磁盘里面加载对应的数据页,而是在 `change buffer` 里面记录了一次操作
2. 写入 `redo log`

可以看到因为有写缓存的存在,其性能与读请求几乎一致

同样可以分析下是否会产生一致性问题: **同样也不会**

1. 数据库宕机,能够从 `redo log` 中恢复数据
2. 读取刚刚写入的数据,会有其他机制保证从磁盘里面取出旧的数据页,并和 `change buffer` 里面的记录完成合并
3. 会有机制保证 `change buffer` 里面的改动在适当的实际刷入磁盘

如果此时发生读取操作,会发生什么呢

1. 发现缓存里没有对应的页,从磁盘里面随机读取一次拿到对应的页放入缓存
2. 将磁盘里面读出来的页和写缓存 `change buffer` 里面的操作进行合并 `merge` 
3. 将 `merge` 后的页根据 `LRU` 算法放入缓存池的对应位置 (老年代)

可以看到: 再写操作发生时,并不会从磁盘里面加载页到缓存里面; 实际上是在读操作到来时,才会从磁盘里面真正加载到缓存里面然后进行 `merge` 操作

#### 为什么说写缓存只能用于 "非唯一索引"

这是由 **一致性** 决定

什么是一致性? 简单回顾下: 数据库保证数据能够从一个正确的状态转换为另一个正确的状态

为什么说 `change buffer` 写缓存在对于 **唯一索引** 的写操作时,没法保证一致性

由于 **唯一索引** 在写入数据时,需要保证数据的 **唯一性**, 而 `change buffer` 在记录写入操作时,并没有去校验这条记录 **是否已经存在**

要校验数据的唯一性,必须要从磁盘里面读取出对应的索引页,以检查数据是否存在

既然这次磁盘操作必不可免,那为什么不直接从磁盘里面读出放到 `buffer pool` 里,然后直接对页进行修改

这样看来在中间添加一个 `change buffer` 写缓存,对于校验索引的唯一性来说,就显得毫无作用了

### 什么场景适合开启写缓存

根据上面的分析,有以下场景适合开启写缓存

1. 数据库里面大多都是 **非唯一索引**
2. 写多读少

什么时候不适合开启写缓存

1. 数据库里面大多都是 **唯一索引**
2. 读多写少 或者说 写入一个数据后,立马读它(因为写缓存没有实际写页,缓存池里面也没有页,只能从磁盘里面加载,这就导致写缓存失效)