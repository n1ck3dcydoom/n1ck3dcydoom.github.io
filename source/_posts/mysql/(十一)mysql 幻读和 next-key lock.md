---
title: (十一)mysql 幻读和 next-key lock
date: 2022-11-06 14:11:53
index_img: /img/mysql.png
categories:
  - mysql
tags:
  - mysql
---

## 什么是幻读

幻读的定义: 事务在执行过程前后两次查询同一个范围内的数据时,后一次读到了前一次没有读到的结果

在可重复读级别下,普通的查询时 **快照读** 是不会观测到其他事务在其中插入的数据的,因此 **幻读** 仅发生在 **当前读** 的操作下

### 幻读带了什么问题

假设有如下三个会话,并且没有针对幻读采取任何措施

且表里面只有 2 条记录 `id = 5, d = 5`, `id = 0, d = 0`, 执行顺序如下

![img.png](https://tva1.sinaimg.cn/large/008vK57jgy1h7vflq7ab8j30rz0f1grs.jpg)

从语义上来说,会话 A 开启了 **当前读** ,所以三次 `select` 查询得到不同的结果,在这个场景下看起来是符合语义的,当前读就是能看到其他未提交会话的更新操作

如果会话 A 在 T1 时刻查询后执行了一次 `update` 操作 `update t set d = 100 where d = 5`

由于会话 B 和 C 都是执行一条 sql 语句,会在执行完成后立马提交事务,而会话 A 因为是通过 `begin` 开启的事务,所以必须在显式声明 `commit` 后才会提交事务,那么 `binlog` 的记录会是什么样的呢

```sql
-- 会话 B
update t set d = 5 where id = 0    -- (0,0,5)

-- 会话 C
inserst into t values(1,1,5)       -- (1,1,5)

-- 会话 A
update t set d = 100 where d = 5   -- (5,5,100) (0,0,100) (1,1,100)
```

如果使用这份 `binlog` 去做主备同步或者备份数据库的话,会导致 `id = 0 和 id = 1` 的数据发生不一致的现象

很明显,会话 A 的 **当前读** 语义上是要对所有 `d = 5` 的数据加上锁,但是后来发现会话 B 将原来 `d != 5 的 id = 0` 的记录给更新为 `d = 5`,而且会话 C 更是插入了一条 `id = 1 且 d = 5` 的数据,这根原来会话 A 给 `d = 5` 加锁的语义发生了冲突

显然会话 A 并没有为所有 `d = 5` 的记录加上行锁,仅仅是锁住了 `id = 5, d = 5` 这一行数据; 如果进一步假设锁的范围变得更加严格,让所有被扫描过的 `d = 5` 的记录加上行锁

![img_1.png](https://tva1.sinaimg.cn/large/008vK57jgy1h7vflvnhywj30lb0990vu.jpg)

但是对于会话 C 呢,由于 `id = 1` 的记录之前并不存在所以自然而言也没有对 `id = ` 的记录加锁,所以会话 C 仍然能够执行,此时 `binlog` 日志记录如下:

```sql
-- 会话 B 被阻塞,
-- update t set d = 5 where id = 0    -- (0,0,5)

-- 会话 C 因为 id = 0 的记录不存在,自然也没有锁,能够正常插入
inserst into t values(1,1,5)       -- (1,1,5)

-- 会话 A
update t set d = 100 where d = 5   -- (5,5,100) (0,0,0) (1,1,100)

-- 会话 B 在会话 A 提交后才能得以更新
update t set d = 5 where id = 0    -- (0,0,5)
```

显然,会话 B 的问题解决了,但是会话 C 的问题还没有解决

可以看到给单独的行加上行锁,或者给扫描过行加上行锁,在 **当前读** 的场景下都无法解决幻读的问题

### 如何解决幻读

InnoDB 引入 `间隙锁` 的概念来解决行锁,先说下 `间隙` 是什么

对于上面的表,只有两条记录的时候 `id = 0, d = 0` 和 `id = 5, d = 5`, 此时把主键 id 放到一条数轴上,有如下表示:

![img_2.png](https://tva1.sinaimg.cn/large/008vK57jgy1h7vfm2gsxnj30fa03cjrd.jpg)

InnoDB 规定 `间隙` 的区间端点为 `左开右闭` ,对于正无穷为了让右区间为闭区间,InnoDB 约定了一个固定的最大值

对于 `间隙` 上面的加锁,就叫做 `间隙锁`

在有了 `间隙锁` 之后,会话 A ,就会为数据两边的 `间隙` 都加上 `间隙锁`,如下图所示

![img_3.png](https://tva1.sinaimg.cn/large/008vK57jgy1h7vfm95entj30om08awfj.jpg)

可以看到当会话 A 查询 `id = 3` 的记录时 `for update` 不仅仅为当前记录加锁,还把周围的间隙也加上了锁; 这样会话 B 在这个间隙里插入记录的时候会被阻塞掉

### 间隙锁和死锁问题

考虑如下场景

![img_4.png](https://tva1.sinaimg.cn/large/008vK57jgy1h7vfme14t9j30rl0ah76b.jpg)

对于会话 A,锁住的间隙是 `(5,max]`, 对于会话 B,锁住的间隙也是 `(5,max]`,可以看到同一个间隙锁可以被多个会话同时加锁,它们之间并不互斥,与间隙锁发生互斥的条件仅仅是 **往间隙当中插入新数据** 

紧接着会话 B 插入数据,由于会话 A 持有了间隙锁,所以会话 B 被阻塞

同理会话 A 插入数据时也因为间隙锁导致阻塞,这里 mysql 的主动死锁检测立马就会返回报错

### 总结

InnoDB 如何解决幻读问题

* 对于快照读, `MVCC` 可以保证幻读不会产生
* 对于当前读, `间隙锁` 保证幻读不会产生

### next-key lock 加锁机制

对于行锁和间隙锁,结合起来称为 `next-key lock`

对于 `next-key lock` 的加锁规则,遵循一下 5 个原则

1. 加锁的基本单位是 `next-key lock`,符合 **前开后闭** 原则
2. 在查询过程当中只对访问到的记录加锁,没有访问的记录不会加锁
3. 等值查询下,如果是唯一索引加锁, `next-key lock` 退化为 `行锁`
4. 等值查询下,向右遍历到第一个不满足条件的记录时, `next-key lock` 退化为 `间隙锁`
5. 唯一索引上的范围查询会遍历到第一个不满足条件的记录为止

假设表有 `id,c,d` 三个记录,主键 `id` 和 普通索引 `c`

并且有记录 `(0,0,0)(5,5,5)(10,10,10)(15,15,15)(20,20,20)(25,25,25)`

#### 1. 唯一索引的等值查询

![img.png](https://tva1.sinaimg.cn/large/008vK57jgy1h7vh481j86j30p008gdgu.jpg)

1. 会话 A 的对 `(5,10]` 加上 `next-key lock`
2. `id=7` 是一个等值查询,且主键 `id` 是一个唯一索引,所以 `next-key lock` 退化为 `行锁`,由于不存在 `id=7` 的记录,所以往右查找到第一个不满足条件的位置 `id=10` 退化为 `间隙锁` ,即 `(5,10)` 
3. 最终的加锁范围 `(5,10)`

由此可见会话 B 插入 `id=8` 会被阻塞,会话 C 更新 `id=10` 可以成功

#### 2. 非唯一索引的等值查询

![img_1.png](https://tva1.sinaimg.cn/large/008vK57jgy1h7vh4fk7w1j30ou099wfo.jpg)

1. 会话 A 对 `(0,5]` 加上 `next-key lock`
2. `c=5` 是一个等值查询,且 `c=5` 是非唯一索引,向右查找到第一个不满足条件的记录 `(10,10,10)` 这个查找过程中都会加上间隙锁 `(5,10]` ,而且 `c=10` 的记录会退化为 `间隙锁` ,即 `(5,10)`
3. 最终的加锁范围 `(0,10)`

为什么 B 更新 `id=5` 的记录能够成功,不是已经有 `(0,10)` 的间隙锁吗

需要注意的是,根据第 2 条原则,只对访问过的记录才加锁; 由于绘画 A 的 sql 是 `select id xxx` 可以看到通过索引 `c` 是覆盖索引的,此时不需要回表查询主键索引

相当于会话 A 的查找记录只使用索引 `c` 而没有用到主键索引,所以会话 A 的加锁仅仅在索引 `c` 上生效,而会话 B 通过主键 id 更新时,是没有 `next-key lock` 存在的,所以会话 B 能够成功执行

同理,会话 C 因为插入 `c=7` 的记录,会被会话 A 创建的 `next-key lock` 锁住,所以会话 C 被阻塞

这个例子说明两点:
* `lock in share mode` 只会锁定覆盖索引,而 `lock for update` 会把涉及到的主键索引一起加锁
* 如果要避免 `lock in share mode` 加读锁但是数据被更新的话,就必须绕开覆盖索引,重新回表让主键索引一起加锁

#### 3. 主键索引的范围查询

![img_2.png](https://tva1.sinaimg.cn/large/008vK57jgy1h7vh4letudj30ou0ebq4k.jpg)

1. 会话 A 对 `(5,10]` 加上 `next-key lock` ,由于 `id=10` 是等值查询, 且是唯一索引,所以退化成 `行锁` ,即 `[10,10]` 这一行
2. 会话 A 对 `(10,15]` 加上 `next-key lock` ,由于 `id<11` 是范围查询,所以会遍历到第一个不满足条件的记录位置,即 `(15,15,15)` ,此时 `next-key lock` 为 `(10,15]` 
3. 最终的加锁范围 `[10,15]`

会话 B 插入 `id=8` 的记录不在 `next-key lock` 当中,操作成功,更新 `id=13` 的记录被锁住,失败阻塞

会话 C 更新 `id=15` 的记录被锁住,失败阻塞

#### 4. 非唯一索引的范围查询

![img_3.png](https://tva1.sinaimg.cn/large/008vK57jgy1h7vh4rrlerj30ou0b2mya.jpg)

1. `c>=10` 是范围查询, 会话 A 对 `(5,10]` 加上 `next-key lock`, 因为 `c` 是非唯一索引,不会退化为 `间隙锁`
2. `c<11` 也是范围查询,会话 A 对 `(10,15]` 加上 `next-key lock`, 同样因为 `c` 是非唯一索引,不会退化为 `间隙锁`
3. 最终的加锁范围 `(5,10]∪(10,15] = (5,15]`

会话 B 插入 `c=8` 的记录被锁住,失败阻塞

会话 C 更新 `c=15` 的记录被锁住,失败阻塞