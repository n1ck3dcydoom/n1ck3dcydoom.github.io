---
title: (六)mysql 刷盘机制
date: 2022-11-05 10:42:22
index_img: /img/mysql.png
categories:
  - mysql
tags:
  - mysql
---

### mysql 的抖动

在日常工作当中,监控 mysql 的 cpu 状况一般可以发现几个特征

1. 随着流量高峰导致的使用率上升,这种随着业务的频繁访问而上升,随着业务冷却的下降,属于正常波动
2. 在平滑的曲线当中,经常会出现 `突刺` 般的抖动

![img.png](https://tva1.sinaimg.cn/large/008vK57jgy1h7u37pk9brj30me05s3yx.jpg)

这种短暂的 `突刺` 抖动,一般情况都是因为 mysql 在做 **刷盘** 操作引起的

### 结合日志系统理解刷盘

对于前面提到的 mysql 的日志系统,以 `redo log` 为例,前面介绍过分为两个部分 `redo log buffer` 和 `redo log file`

`buffer` 保存在内存里, `file` 保存在磁盘上,这也是为了平衡内存和磁盘访问速率不统一的问题

但是保存在内存里的数据终究是不可靠的,会随着断电而丢失,所以必须在适当的时机将内存里的数据写入磁盘完成持久化操作,保证数据的安全

#### 脏页和干净页

当内存里面的数据页和磁盘里面的对应数据页内容不一致的时候,这个内存页就被称为 `脏页`

反之若保持一致,则称内存页为 `干净页`

回顾一下之前的数据写入过程,首先记录 `redo log` 这是由 mysql 写前日志的特性保证,然后将改动在 `buffer pool` 里面写入,这里可以结合缓存相关的东西一起复习,最后 mysql
找一个合适的时机,将 `redo log` 里面记录的操作写入磁盘完成持久化

![img_1.png](https://tva1.sinaimg.cn/large/008vK57jgy1h7u37w4jo6j30mt0d976q.jpg)

### 什么时候触发刷盘操作

1. 当 `redo log` 的 `write_pos` 已经追上 `check_point` 的时候,表明 `redo log` 已经写满了无法再继续写入新数据,此时整个数据库的写操作都将被阻塞,必须要将 `check_point` 后面的数据刷入磁盘,以腾出空间让 `redo log` 恢复继续写入

![img_2.png](https://tva1.sinaimg.cn/large/008vK57jgy1h7u38318laj30gb0fkace.jpg)

当 `check_point` 的位置从 `cp` 推进到 `cp'` 的时候,就必须把这个区间内的所有的日志(浅绿色部分)都刷入磁盘,当完成刷盘操作后,`check_point`的位置推进到 `cp'` 这样就空出来新的位置给 `write_pos` 继续推进

2. 当缓冲池内存不足的时候,此时就必须要淘汰掉里面的部分数据页(对应可以结合 mysql 的缓存机制复习),如果从 `LRU` 里面淘汰的是干净页那还好说,直接移出 `LRU` 即可; 如果淘汰的是脏页,就必须要刷盘

为何不考虑直接丢弃脏页,下次从磁盘读取旧的内存页,然后和 `redo log` 里面的操作结合返回呢

从性能角度上来说, 这里的 `merge` 操作对于读取页来说相对复杂了

而且刷盘能够保证一致性:

* 若内存页里有数据,无论是脏页还是干净页,一定是最新的正确数据,命中缓存后直接返回
* 若内存页里没有数据,那么磁盘里面的一定是正确数据,从磁盘读入内存后直接返回即可,也不需要额外的 `merge` 操作

3. 当 mysql 检测到系统负载不高的时候,也会进行刷盘操作; 即使系统的负载很高,也要见缝插针的刷脏页,避免造成内存不够或者 `redo log` 写满的情况发生(这个频率是每秒 1 次)

4. 最后,当 mysql 需要停机的时候,关闭 mysql 进程之前,会将内存里面的所有脏页一次性全部刷入磁盘,避免内存里面的数据丢失

### 着重考虑下第 2 点的刷盘情况

结合之前的缓存技术一起复习,当需要访问数据的时候,先检查缓存池里是否已有对应的页,若命中缓存则快速返回; 否则从磁盘里面读取对应的内存页

如果此时缓存池还没有写满,那么直接放入 `LRU` 即可

如果缓存池已经写满,就需要根据 `LRU` 淘汰页; 淘汰的是脏页,必须刷盘; 淘汰的是干净页,无需刷盘

mysql 通过两个参数来控制刷脏页的速率

1. 当前 `buffer pool` 里面的脏页比例 M
2. 当前 `redo log` 的写盘速度 N

简单来说就是取 `R = max(M, N)`,然后 mysql 就以 `R% * 磁盘写入能力` 的速率刷新脏页

### 连坐刷新

若一次请求需要刷新一个脏页,根据局部性原理,mysql 会判断当前页旁边的数据页是否也是脏页,如果也是脏页,就一起刷新掉; 而且这个判断机制会蔓延下去,也就是说如果邻居是脏页,还要继续判断邻居的邻居

这样最终可能导致一次简单的请求,原本刷新一个脏页就可完成,最后刷新的大批量的脏页,反而拖慢了整体查询的性能