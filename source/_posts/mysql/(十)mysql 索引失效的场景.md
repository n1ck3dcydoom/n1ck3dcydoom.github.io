---
title: (十)mysql 索引失效的场景
date: 2022-11-05 20:26:30
index_img: /img/mysql.png
categories:
  - mysql 
tags:
  - mysql
---

## mysql 当中索引失效的场景

### 索引字段使用函数

思考下 mysql 为何能够通过索引快速定位数据,是因为 `B+` 同层节点的有序性

如果说某些操作打破了这种有序性,那么就无法利用索引树来检索数据了,只能走全表扫描

例如 `select a from t where sum(a) > 5` 这种对索引列做函数操作的,很有可能破坏索引的有序性

其实并不是说 mysql 对于这种函数操作完全放弃了索引,即使走全表扫描,仍然可以优化具体使用什么索引树来做全盘扫描

如果字段 `a` 上建立了索引,那么扫描索引 `a` 显然比扫描主键索引更快,这是因为 `索引覆盖` 带来的优化,不用取出整行数据,索引 `a` 已经包含了列 `a` 所需要的所有数据

同样的,还有更加隐蔽的操作也会导致索引失效

例如 `select * from t where id + 1 = 10000` 这里 `+1` 不会破坏有效性,但是仍然无法通过 id 定位到 `9999` 这一行 因为 mysql 无法计算 `多少 id +1 才能等于 10000`
,还是需要全表扫描

如果改为 `where id = 10000 -1` 那么即可快速通过索引定位到 `9999` 行

### 隐式类型转换会导致索引失效

假如存在一个 `varchar()` 类型的列 `order_id` 上建有索引, 以下 sql 会让索引失效

```sql
select * from orders where order_id = 12345
```

注意到 `order_id` 本身是 `varchar()` 类型,但是 sql 语句里面却是用 `int` 整型变量在做比较,这会导致发生 **隐形类型转换** 从而导致索引失效

**mysql 将数字和字符串作为比较的话,会把字符串转换为数字**

为何隐式类型转换会导致索引失效

在了解到字符串如果和数字作对比,会把字符串转换为数字之后,上面 sql 的本质就发生了改变

```sql
select * from orders where CAST(order_id AS int) = 12345
```

可以看到这里的隐式类型转换实际上是对字符串调用了 `CAST()` 函数,而之前说过,如果在索引列上有函数操作的话,可能会破坏索引树的有序性,从而 mysql 不使用索引改用全表扫描

同样的,如果在做关联查询的时候,两个连接的字段的字符编码不相同,也会触发隐式类型转换,从而导致索引失效

### 最左前缀原则

如果存在联合索引,则查询列里面的索引必须从最左侧开始且不允许跳过中间的索引列

例如存在联合索引 `a,b,c` ,如下 sql 语句属于 **全值匹配** 可以命中索引

```sql
select * from t where a = 1 and b = 2 and c = 3
```

这里跟查询列的顺序无关,只要在逻辑上满足索引列从左到右的匹配顺序即可,myslq 优化器会在内部自动调整索引的顺序

```sql
select * from t where b = 2 and c = 3 and a = 1
```

**非全值匹配** 只要满足从左到右的前缀即可

```sql
select * from t where a = 1 and b = 2
```

但是不能出现缺少或者跳过,这样会导致最左前缀原则失效,从而导致索引失效

```sql
-- 从左往右缺少 a
select * from t where b = 2 and c = 3 
-- 跳过 b
select * from t where a = 1 and c = 3
```

同样对于模糊查找也必须满足最左前缀原则

```sql
-- 模糊检索最左前缀 a 是确定的,后面 % 才是通配符,符合最左前缀原则,可以命中索引 a
select * from t where a like 'a%'

-- 最左前缀 % 是通配符,属于不确定的,破坏了最左前缀原则,不能命中索引 a
select * from t where a like '%a'
```

### 使用 OR 关键字

例如只有列 `a` 有索引

```sql
select * from t where a = 1 or b = 2
```

此时会导致索引失效,假设只有 `where b = 2` 此时肯定是全表扫描,已经得到 `a,b` 的值,就不用再遍历 `a` 的索引了; 否则使用 `a` 的索引后还需要一次全表扫描才能判断 `b` 的条件

使用 `or` 关键字的时候,必须保证两边都有索引才可以

### 负向查询

常见的负向查询有 `NOT, IS NOT NULL, !=, NOT IN, NOT LIKE` 等

这些查询不一定会导致索引失效,mysql 在实际执行的过程当中,根据优化器的判断决定是否选择索引,亦或者是全表扫描