---
title: (六)jvm 锁和并发问题
date: 2022-11-16 11:11:14
index_img: /img/java.png
categories:
  - jvm
tags:
  - jvm
---

### 线程安全问题

当一个对象被多个线程同时访问时,如果不用考虑额外的线程调度设计,也不需要进行同步操作或者其他任何协调设计,那么这个对象就是线程安全的

### java 当中的线程安全问题

1. 不可变对象,如果一个对象或者变量被 `final` 关键字修饰; 那么这个变量就是绝对线程安全的
2. 绝对线程安全
3. 相对线程安全: java 大多数据集合对象声称的线程安全都属于相对线程安全,即只有在特定的调用顺序下才需要额外的同步手段
4. 线程兼容
5. 线程对立

### java 实现线程安全的手段

#### 互斥同步

java 通过 `synchronized` 关键字实现同步互斥锁

`synchronized` 是可重入锁,对于已经得到锁的对象反复进入同一块临界区时,不会发生阻塞; 锁的计数器加一,退出临界区后锁的计数器减一,当计数器等于 0 之后释放锁

`synchronized` 是不可抢占的锁,后续申请等待的线程将会无条件的阻塞

jdk 5 以后引入了 `java.util.concurrent` 并发包,里面提供了可重入锁的实现 `ReentrantLock`, 其特性如下

* 等待可中断: 当线程等待一个锁对象的时候,可以选择中断当前等待去处理其他事,无需像 `synchronized` 无限等待
* 公平锁: 多个线程等待同一个锁的时候,必须严格按照申请时间进行等待; 默认情况下 `ReentrantLock` 是非公平锁, `synchronized` 也是非公平锁
* 绑定多个条件: 可以把锁绑定在多个条件上

对于 `JUC 的 Lock` 和 `synchronized` ,在 jdk 6 以后大多数情况下,最好还是选择 `synchronized`

* `synchronized` 是 java 语法层面的东西,每个人都应该了解; 而 `JUC` 则是以扩展包的形式提供服务,并不是所有人都了解过 `JUC`
* `synchronized` 由 jmv 保证了锁在用完后一定会被释放; 而 `JUC` 字需要在 `finally` 语句块当中释放锁; 一旦发生错误或者没有释放锁,则可能导致锁永远不会被释放
* jdk 6 以后对 `synchronized` 做了很多性能优化,大多数场景下其性能几乎与 `JUC` 差不多

#### 非阻塞同步

互斥同步可以看做是一种 `悲观` 的实现,而现在有另一种策略去检测那就是: 基于冲突检测的 `乐观` 并发策略:

当一个线程需要等待一把锁是,不在 `悲观` 的阻塞直到被唤醒,而是会不停的检测这个锁是否可获取,直到最后真正获得锁

乐观锁的实现要求硬件层次做相应的准备,例如冲突检测这个过程就需要由硬件去保证是原子性操作; 如果在这过程当中再引入互斥同步,就得不偿失了

java 在乐观锁的实现上采用的方式是 `CAS` 比较并交换策略

`CAS` 由三个操作数构成,原始数据 A,需要更新的数据 B,数据地址(引用) Y

当 `CAS` 指令执行时,会检测数据地址 Y 是否符合 A 的预期,如果不符合则不执行更新; 否则会将其更新为新值 B; 无论更新与否,最后都只会返回旧值 A

最简单的实现就是 java 里面的各种原子类 `AtomicInteger` 其自增方法就是不断地尝试将下一个 +1 值赋值给自己,每次尝试前都会执行 `CAS` 如果旧值发生了改变,则不会自增,进入下一次循环

朴素 `CAS` 导致的 `ABA` 问题: 如果一个线程进行 `CAS` 操作前发现值为 A,当线程准备赋值的时候检测此时值还是 A,那么线程能简单的认为这个值没有被其他线程更新过吗(即其他线程赋值 A)

由于 `ABA` 问题不会影响并发场景的正确性,非要解决 `ABA` 问题的话 `JUC` 提供了基于版本号的 `CAS` 操作,这样每次修改都会令版本号改变,可以通过版本号去解决 `ABA` 问题

#### 可重入代码块

对于那些可重入的代码块,其完全不依赖全局变量或者局部变量,而只是依靠输入的参数; 这样即使多少次调用函数只要给定的参数不发生变化,那么函数的返回值就是确定的

对于这种可重入的代码块,不需要使用额外的同步操作就可以实现并发安全

线程本地存储 `ThreadLocal` :

每个线程 `Thread` 都维护了一个 `ThreadLocalMap` 结构里面保存了只有当前线程才能访问到的变量值,所以对于这些变量来说也都是绝对并发安全的

### 锁优化

由于 `synchronized` 锁是一个重量级实现,jdk 6 以后引入了大量对 `synchronized` 的锁优化; 包括 `自适应自旋锁`,`锁消除`,`锁粗化`,`轻量级锁`,`偏向锁` 等等技术

#### 自适应自旋锁

为了避免互斥同步导致的大量上下文切换开销,如果说一个锁的平均持有时间很短,那么让后续等待锁的线程稍微多等一会儿,而不是立即挂起,这将减少很多上下文切换开销

当时自旋锁并不能代替同步; 自选本身不会让出 CPU 资源,如果一个自旋进程一直无法结束并获得锁,那么这将导致 CPU 资源的浪费; java 为自旋等待设置了一个最大次数,超过多少次自旋后还没能获得锁就挂起,让出宝贵的 CPU 资源

jdk 6 引入了 `自适应自旋锁` 其 `自适应` 就是每次自旋等待的时间会发生调整:

如果当前锁上一次自旋等待时间很短,那么 jvm 也会认为这次自旋等待的时间应该也不会很长,就会多等待几次,例如自旋 100 次

如果当前锁上一次自旋等待时间很长,那么 jvm 也不会浪费时间去自旋等待,要么只等待几次,或者干脆跳过自旋等待直接挂起,避免 CPU 资源浪费

#### 锁消除

对于声明了需要使用 `synchronized` 的代码块,在进行 `逃逸分析` 后如果发现其变量的作用范围都不会逃逸出去被其他线程访问到,那么 jvm 就会认为当前 `synchronized` 是不需要的,就会去掉这个同步代码块上的锁; 把当前代码块当做 `栈上` 数据对待,自然也就不需要同步操作

#### 锁粗化

当 jvm 发现对于一些零散的代码块都有加锁操作,此时 jvm 会把加锁范围粗话,不再单独为每个零散的代码块加锁,而是对所有需要加锁代码块的外部进行加锁

最简单的例子如下:

```java
public void foo(){
    while (true) {
        synchronized (this) {
            // do something
        }
    }
}
```

循环当中每次都需要获取当前对象的锁,此时可能会被 jvm 将锁的范围粗化到整个方法上,这样只需要一次加锁就够了; 避免多次加锁带来的性能开销

#### 轻量级锁

jvm 的对象头里面分为两个部分: 
1. 对象运行时的自身数据,如 GC 年龄,哈希 code 等等,也被称作 `Mark Word`,其中有 `2bit` 的锁标志位记录了当前锁的状态
2. 对象运行时指向方法区的指针

轻量级锁的实现原理:

当即将进入临界区时,如果对象还没有被锁定,jvm 就会在栈帧里面建立一个 `Lock Record` 锁空间用于保存当前对象的 `Mark Word` 记录

![img.png](https://tva1.sinaimg.cn/large/008vK57jgy1h86y0v7l8oj30s30d3q5b.jpg)

然后 jvm 尝试使用 `CAS` 将当前对象的 `Mark Word` 更新为指向这个 `Lock Record` 的指针; 如果这个操作成功了,此时就认为当前线程持有了对象的 `轻量级锁`

![img_1.png](https://tva1.sinaimg.cn/large/008vK57jgy1h86y0zxy5bj30om0g9ju2.jpg)

如果这个 `CAS` 操作失败,那么就认为其他线程已经持有过这个对象的锁,此时就需要将锁膨胀为 `重量级` 锁,后续申请锁的线程都将进入阻塞状态

轻量级锁通过 `CAS` 操作来实现同步过程,如果 `CAS` 成功则说明加锁成功,反之则失败

如果没有竞争,那么轻量级锁的 `CAS` 操作相比于使用互斥同步来说,能节约不少开销; 而如果一个资源本身存在很大的竞争,此时的轻量级锁最终都会膨胀为重量级锁,这时候的 `CAS` 操作反而显得是多余的了,还不如直接进入互斥同步

#### 偏向锁

偏向锁旨在轻量级锁的基础上,进一步优化对于无竞争场景的对象加锁过程的性能开销

对于轻量级锁,如果线程反复加锁,每次的 `CAS` 操作就显得很多余

对于第一次加锁成功的线程,此时 jvm 会把锁标志位记录为 `偏向锁` 状态; 这样后续线程再进行加锁操作的时候,判断处于 `偏向锁` 状态后,连 `CAS` 操作都可以省略掉,直接进入临界区