---
title: (二)jvm 垃圾回收机制
date: 2022-11-15 12:56:45
index_img: /img/java.png
categories:
  - jvm
tags:
  - jvm
---

### jvm 那些地方需要垃圾回收

对于 `程序计数器` `虚拟机栈` `本地方法栈` 这三个地方,随着线程的创建而产生,又随着线程的销毁而灭; 里面的数据随着线程的执行能够保证符合预期,且这些结构在类结构确定下来之后就能随之敲定

这三个区域的回收是具有确定性的,当线程销毁时,自然也可简单的将之前分配给线程的区域进行回收; 无需太关注这三个部分的垃圾回收

而对于 `堆` `方法区` 这两个地方,有着很不一样的不确定性:类或者实例所需要的内存不一样,而且实例里面的各个字段设置也都不一样; 这些只有在运行时才能确定下来

垃圾回收机制所需要着重关注的就是对于这些需要动态回收的地方

### 如何确认一个对象可以被回收掉

#### 引用计数法

每个对象维护一个计数器,当有其他地方引用之后就 +1, 没有引用之后就 -1, 当这个对象的引用计数器等于 0 之后,就可以被回收掉

然而实际上 jvm 并没有采用引用计数法,因为如果两个对象存在循环引用时,其计数器的值永远不会成为 0

#### 可达性分析

jvm 实际选用的是 `可达性分析` 算法,来判断一个对象是否能够被垃圾回收掉

`可达性分析` 算法从一个 `GC Root` 对象作为起点,从起点开始根据引用关系向下搜索; 如果某个对象无法通过 `引用链` 而被访问到,则可以认为这个对象与 `GC Root` 节点之间不存在任何的引用关系,则说明当前对象可以被垃圾回收掉

常见的作为 `GC Root` 的对象如下:

* 虚拟机栈当中的引用对象
* 方法区的各种静态对象, 常量引用
* 本地方法当中的对象
* 虚拟机内部的常驻对象,例如类加载器
* 持有同步锁的对象
* 等等....

### 引用类型

什么是引用? 引用 `reference` 传统理解上就是指向某个对象,内存的指针,代表的就是一块连续内存的 `起始地址`

在 jdk 1.2 之后对引用的类型做了 4 个细分

1. 强引用

程序中最为普遍的引用关系都是 `强引用` ,即 `Object obj = new Object()` 这种方式创建的引用都属于强引用; 只要一个对象有强引用关系,就一定不会被垃圾回收掉

2. 软引用

`软引用` 指的是哪些引用关系并不如强引用的,当进行首次垃圾回收后,会把这些 `软引用` 对象放入一个等待区域; 在进行第二次垃圾回收后,如果内存还是不够用,则会回收掉这些 `软引用` 对象; 通过 `SoftReference` 方式创建

3. 弱引用

`弱引用` 的关系比 `软引用` 还要差,它只会存活于下一次垃圾回收之前; 当下一次垃圾回收来临时,无论内存是否够用,都会把 `弱引用` 对象给回收掉; 通过 `WeakReference` 方式创建

4. 虚引用

`虚引用` 是引用关系最弱的,无法通过 `虚引用` 来获取对象实例,`虚引用` 的存在完全不影响对象的生存周期; 其唯一的作用就是当 `虚引用` 的对象发生垃圾回收后,能够产生一个系统通知而已; 通过 `PhantomReference` 方式创建

### 对象的 finalize() 方法

当一个对象在可达性分析后被标记为 `GC 不可达` 后,并不会被立即回收掉, 要真正回收一个对象,至少需要被两次标记过程: 当第一次被标记后,随后进行一次筛选,这个筛选判断的条件是是否有执行 `finalize()` 方法

如果对象并没有重写 `finalize()` 方法,或者已经被调用过 `finalize()` 方法,都会被 jvm 认为是 `没有必要执行`

而对于那些有明确要求要执行 `finalize()` 方法的对象,jvm 会把这些对象放入一个缓刑队列,并且有一个低优先级的线程去执行这个队列里面对象的 `finalize()` 方法

当时这个线程并不保证 `finalize()` 方法一定能够执行完成,如果方法里面有死循环则可能导致这个本该被回收的对象再也无法回收; 甚至会影响到整个垃圾回收的过程

一个对象被标记为不可达之后,最后的自救机会就是在 `finalize()` 方法里面,重新和引用链上的任何一个对象建立关联即可; 这样在第二次筛选的时候就可以逃出生天

但是一个对象的 `finalize()` 方法只会被执行一次,在下一次垃圾回收到来的时候,可能就会被彻底回收掉了

### 方法区的垃圾回收

对于那些用不到的常量对象,如何确定是否需要进行垃圾回收

* 常量对象的所有实例都被回收,也不存在子类或者派生类
* 对应的类加载器也被回收掉
* 不存在 `Class` 引用,即无法在任何地方通过反射的方式访问该对象

通常来说,当一个程序大量用到 `反射` `动态代理` 等技术的时候,就要求程序具备 `卸载类` 的能力,否则将会导致 jvm 的 `永久代` 或者 `元空间` 膨胀

### 垃圾回收算法

#### 分代收集理论

jvm 将整个堆空间分为 `年轻代` 和 `老年代`; 几乎每次垃圾回收之后,年轻代的对象都会死去大部分,每次活下来的年轻代将会逐步进入老年代

针对于 `年轻代` 的回收叫做: `Young GC / Minor GC`

针对于 `老年代` 的回收叫做: `Old GC / Major GC`

针对于整个堆空间和方法区的回收叫做: `Full GC`

#### 标记-清除算法

这是出现最早的垃圾回收算法,分为两个过程

* 标记那些 GC 不可达的对象
* 清理那些 GC 不可达的对象

这个算法存在两个明显的问题: 标记时需要扫描的对象过多,执行效率低; 清理后会导致严重的内存碎片问题

当标记清除执行过后,留下许多内存空洞,这些空洞又不满足下一次内存分配; 这又会导致下一次垃圾回收; 从而陷入了死循环

![img.png](https://tva1.sinaimg.cn/large/008vK57jgy1h85us3y9xwj30mm0c3tab.jpg)

#### 标记-复制算法

为了解决 `标记-清除算法` 一次扫描的对象过多问题, `标记-复制算法` 只使用堆空间的一半; 为了解决内存空洞的问题,会在一半的标记清除完成之后,将剩余的内存空间全部复制到另一半区域,同时调整其位置,使得内存是连续的

这个算法也存在明显的问题: 如果一次垃圾回收之后存活的对象较多,此时会进行大量内存拷贝; 而且每次只使用了堆空间的一半,其空间使用率很低

![img_1.png](https://tva1.sinaimg.cn/large/008vK57jgy1h85usb8xgmj30mw0bv75u.jpg)

#### 标记-整理算法

在 `标记-清除算法` 和 `标记-复制算法` 的基础上,结合两个算法的优点,提出了 `标记-整理算法`

* 使用整个堆空间
* 在一次标记清除之后,将活下来的对象全部向内存空间的一端移动,使得内存空间保持连续

![img_2.png](https://tva1.sinaimg.cn/large/008vK57jgy1h85uslntxfj30mq0bw0ub.jpg)

#### 和稀泥式的解决方法

由于移动对象会带来额外的性能开销,通常被称为 `Stop the world`, 一些常见的垃圾回收器在大部分时候会使用 `标记-清除算法`  当其产生的内存碎片率达到一个阈值之后,才会使用 `标记-整理算法`




## 垃圾回收器

按照分代收集理论,将垃圾回收器分为工作在年轻代的, 工作在老年代的, 以及两者皆可的

1. 年轻代垃圾回收器
   * SerialNew
   * ParNew
   * ParallelScavenge
2. 老年代垃圾回收器
   * SeriaOld
   * parallelOld
   * CMS
3. 两者皆可的
   * G1

### SerialNew 垃圾回收器

从名字上可以得知, `Serial` 在工作的时候是串行的,单线程的; 而且垃圾回收的时候,其他所有线程都要停下来等待垃圾回收结束以后,才能恢复工作; 这个停顿的动作被称作 `Stop the world`   

由于 `Serial` 需要停止其他所有线程来进行垃圾回收,所以相当于垃圾回收的时候整个 CPU 资源都集中在处理一件事上面,这使得垃圾回收的效率非常高

在小型,微型服务上,进行一次 `STW` 通常也就几十毫秒,只要不是频繁发生这是完全可以接受的

### ParNew 垃圾回收器

在 `Serial` 的基础上,引入了多线程回收,其他并没有与 `Serial` 有太多差距,仍然有大量的 `STW` 产生

但是在 jdk 9 出来以前 `ParNew` 是唯一一个能够和 `CMS` 一起工作的垃圾回收器,所以这也成为了大量主流的垃圾回收器的配置方式

### Parallel Scavenge 垃圾回收器

与 `CMS` 这类追求更短的 `STW` 的垃圾回收器相比, `Parallel` 追求的是更高的系统吞吐量

### SerialOld 垃圾回收器

与 `New` 版本几乎没有区别,现在唯一的作用就是用来当做 `CMS` 出现并发错误后的备用回收方案

### Paralled Old 垃圾回收器

与 `New` 版本几乎没有区别,仅仅是为了关注更高的系统吞吐量时才会考虑

### CMS 垃圾回收器

`CMS (concurrent mark sweep)` 的首要目标就是,尽可能的使 `STW` 更短, `CMS` 回收器被大量的运用在对时间响应有要求的应用服务上

从名字上可以看出 `Mark Sweep` 其采用的是 `标记-清理算法` ,分为以下四个步骤运行:

1. 初始标记 (需要 STW)

简单的从 `GC Root` 对象标记一下有直接引用的对象,这个过程很快,即使引起 STW 也能够容忍

2. 并发标记

从 `GC Root` 对象开始 `并发` 地标记整个引用对象图; 这个过程较长,但是可以和用户线程并发执行,不会引起 STW

3. 重新标记 (需要 STW)

由于并发标记过程当中,用户线程仍然能够工作,所以可能导致对象图里面的引用关系被修改; 所以重新标记需要对这部分 `增量更新` 重新进行一次标记; 这个过程稍微长一点,而且也会引起 STW 但是也比并发标记过程短

4. 并发清除

当完成所有的标记过程后,开始并发清除这些被标记的对象; 这个过程可以和用户线程一起并发执行

![img_3.png](https://tva1.sinaimg.cn/large/008vK57jgy1h85ussrly8j30nh058tar.jpg)

`CMS` 的缺点:

`CMS` 对处理器资源非常敏感,即使 `CMS` 可以在标记和清除的过程中与用户线程并发执行,这导致它会占用部分处理器资源; 如果本身处理器资源非常有限,此时在使用一部分去保证 `CMS` 的运行,将导致正常请求处理不及时

由于 `CMS` 的并发特性,在清除垃圾的时候,无法清理掉=那些并发线程产生在标记后又产生的垃圾,这部分垃圾叫做 `浮动垃圾`,所有的浮动垃圾只好等待下一次垃圾回收的到来

因为有浮动垃圾的存在,所以 jvm 不得不为其预留一部分内存空间以保证用户线程的正常工作; jvm 设置了一个阈值,当浮动垃圾的比例达到 `92% jdk 6` 之后就启动 `CMS` 进行垃圾回收

如果当内存空间不足以用户线程正常使用时,还可能触发 `Concurrent model failure` 错误,这将导致 jvm 启动备用方案 `SerialOld` 进行一次 STW 的老年代回收

同样的,由于采用的是 `标记-清除算法` 也会导致老年代内存空洞问题,如果一个对象进入老年代,而无法进行内存分配的话,就会触发一次 `Full GC`

### G1 垃圾回收器

`G1` 将整个堆空间分为若干的 `Region` 区域,这样 `G1` 就不再区分老年代或者年轻代,只关注于那些需要进行垃圾回收的 `Region` ,对于那些跨代指针,同样采用 `记忆集或者卡表` 去记录

ZGC 以及 redhat 的 Shenandoah 太高端了

### 常见的分代机制

常见的分代由 3 个部分组成: `Eden`,`Survivor` 和 `Old`

其中年轻代细分为一个 `Eden` 和两个 `Survivor` 比例为 `8:1:1`

为了避免一个大对象在 `Eden` 和 `Survivor` 之间反复复制,通常直接把一个大对象的分配到老年代里面

jvm 为每个对象分配了一个 `对象年龄计数器` ,在一次 `minor gc` 之后,会把 `Eden` 和 一个 `Survivor` 存活下来的对象复制到另一个 `Survivor` 里面,此时对象的对象计数器 +1 ,当这个计数器的值达到某个阈值 (默认为 15) 之后,就会被放入老年代

更特殊的,并不是说一定要达到 15 岁才会进入老年代,如果 `Survivor` 里面同年龄的对象内存综合超过了一个 `Survivor` 的大小后,为了避免反复地复制,也会直接把这部分对象放入老年代

### 空间分配担保

在进行 `Minor GC` 之前,如果老年代剩余的连续空间已经无法放入即将晋升老年代的对象; 此时就不得不触发一次 `Full GC` 来清理部分老年代的对象

如果 jvm 设置允许分配担保失败,则会检查一下老年代对象的平均大小和当前即将晋升的对象; 如果平均大小大于晋升对象,则 `尝试` 进行一次 `Minor GC` 即使可能失败导致 `Full GC` ; 如果不允许分配担保失败,则判断大小不够后会直接进行一次 `Full GC`