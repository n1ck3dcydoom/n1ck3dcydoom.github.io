---
title: (十二)redis 缓存问题
date: 2022-11-13 10:45:45
index_img: /img/redis.png
categories:
  - redis
tags:
  - redis
---

### redis 缓存所面临的问题

在高并发业务下,数据库往往是性能最为薄弱的环节; 所以使用 redis 放在业务和数据库之间,作为旁路缓存起到一个缓冲的作用,避免所有请求全部打到数据库; 这样可以大大的缓解数据库的压力

当 redis 作为旁路缓存使用时,就不得不考虑以下几个问题

1. 缓存穿透
2. 缓存击穿
3. 缓存雪崩
4. 缓存污染或者缓存写满(回顾下缓存的淘汰策略)
5. 缓存和数据库的一致性问题

### 缓存穿透

什么是 `缓存穿透`, 就是一个数据 **即不存在于数据库,也不存在于缓存里** ; 每次对这个数据的请求都不会命中缓存,而是直接发向数据库

由于数据库里面也没有,所以也不会回写到缓存里,导致缓存的存在失去了意义

在大量请求的场景下,如有有人恶意构造不存在的 `key` 从而发起攻击,很可能导致数据库压力过大

解决方案:

1. 业务层做校验,对于一些请求非法资源的,直接拦截掉; 例如 `id < 0`

实际上业务层无法做到对所有非法请求的拦截,只能过滤掉一些常规的明显的非法参数

2. 如果在缓存和数据库里面都查询不到数据,业务层可以回写一个空数据,即 `key-null` 到缓存里面; 这样下次对于这个不存在的 `key` 的请求,就可以由缓存快速返回空值 `null`

如果有大量不存在的 `key` 请求都通过这种方式在缓存里面写入了空 `key-null`,就会造成缓存的内存空间被浪费; 可以对这些 `key-null` 设置一个较小的过期时间 `10s`
之类的,避免缓存里面长时间被塞满空 `key-null` 键值对

3. 使用布隆过滤器

#### 使用布隆过滤器来减少缓存穿透的问题

布隆过滤器是一种 `概率型数据结构` ,用于在有限的内存空间内,快速判断一个元素是否存在于集合当中

为什么说是 `概率型` 因为布隆过滤器是基于统计判断的; 如果布隆过滤器说元素存在于集合当中,此时元素 **可能** 不存在(统计发生了偏差错误); 如果布隆过滤器说元素不存在于集合当中,此时元素 **一定** 不存在

布隆过滤器的基本数据结构其实就是一个 `bit 数组`,首先分配一块内存空间作为 `bit 数组` ,数组的每个位都初始化为 `0`

当有一个元素加入时,布隆过滤器使用 `K` 个互相独立的哈希函数计算得到 `K` 个不同的位置,然后把这 `K` 个不同的位置设置为 `1`

当需要检测一个元素是否存在于集合当中时,则仍然使用这些哈希函数计算得到对应的位置,判断这些位置上是否全部是 `1`,如果全部是 `1` ,则元素 `可能` 存在于集合当中; 如果有 `0` 出现,则元素 `一定` 不存在集合当中

![img.png](https://tva1.sinaimg.cn/large/008vK57jgy1h83cyg2hrbj30lm0cl424.jpg)

由于布隆过滤器使用哈希函数计算,不可避免会产生 `哈希碰撞`

即不同的元素经过哈希函数计算后,得到了相同的哈希值; 导致集合只有其中一个元素时,也会判断另一个元素存在

而且布隆过滤器存在几个比较致命的问题:

1. 不允许对布隆过滤器中的元素做删除操作
2. 当布隆过滤当中的元素增多时,其误判率会增大

因为存在 `哈希碰撞` 的问题,导致一个元素被删除后,将 `bit 位` 置 `0` 的时候会影响其他元素的哈希值; 因此导致布隆过滤也认为其他被影响到的元素不存在于集合当中

### 缓存击穿

什么是 `缓存击穿`, 针对热点数据的访问非常频繁,而缓存里面没有这条数据,导致大量请求在短时间内全部打到了数据库,因为数据库压力激增

什么情况会导致缓存击穿: 当某个热点数据过期后,被 redis 淘汰掉,此时大量请求会穿过 redis 直接来到数据库

![img_1.png](https://tva1.sinaimg.cn/large/008vK57jgy1h83cymyd61j30ho09i75x.jpg)

对于缓存击穿问题,解决办法也比较直接

1. 既然是由于热点数据过期导致未命中缓存,就直接把热点数据设置一个很长的过期时间直到大流量时间过去; 或者干脆设置热点数据永不过期
2. 缓存击穿是因为短时间内高并发请求透过缓存直接打到数据库; 针对高并发场景下,一个最原始最直接的办法就是 `加锁互斥串行化`

针对加锁,主要实现如下:

* 第一个拿到锁的线程查询数据库后,回写到缓存里
* 后面没拿到锁的线程全部排队等待锁
* 当第一个线程完成缓存回写之后,后续所有请求都会由缓存直接返回; 即使存在加锁和释放的过程也很短暂

### 缓存雪崩

什么是 `缓存雪崩`, 缓存击穿是一个 `key` 发生过期导致针对这个 `key` 的请求全部打到数据库; 而 `缓存雪崩` 就是短时间内, `大量` 的 `key` 发生过期,从而引发大量数据打入数据库,导致数据库压力激增

`缓存雪崩` 和 `缓存击穿` 一个很明显的区别就是: 击穿是针对一个 `key` 过期的大量并发请求; 而雪崩是大量 `key` 过期时的大量并发请求; 后者对业务的影响更为严重

#### 缓存雪崩的原因之一: 短时间内大量数据过期

很简单的一个场景,例如有一批热点短视频需要由运营发布上线,此时为了配合运营,开发人员使用批处理任务或者脚本将这批视频数据刷入缓存里面,由于是批处理任务所以这些视频数据被设置了相同的过期时间

当这个过期时间到达后,这批热点数据立马全部在缓存里面失效; 后续所有对这批数据的请求,将会全部直接打到数据库,引发缓存雪崩

![img_2.png](https://tva1.sinaimg.cn/large/008vK57jgy1h83cysg1ovj30hh09jwg9.jpg)

解决的办法也很简单,针对批量设置热点数据过期的问题,可以引入一个随机数,每次对数据设置过期时间 `expire` 时,都为其加上一个随机数 `random` 这样可以有效的解决相同过期时间到达后,大量数据的过期

除了添加随机过期时间,还可以从业务层面直接降级熔断

* 如果是非关键路径上的请求,则可以在业务层暂时快速失败,提前返回错误,控制或者预先准备好的预定义数据
* 如果是关键路径上的请求,则允许这部分请求先打到数据库; 这样可以减少直接进入数据的请求量; 当这些请求完成了缓存回写后,后续的请求依然可以通过缓存快速得到结果

服务限流也是一种有效手段,例如业务的请求量是 `10000/s` ,而其中 `9000` 个可以在 redis 处理直接返回,剩下的 `1000` 个只能由数据库提供支持

在某一时刻 redis 宕机不可用,此时大量 `key` 全部失效,导致请求压力一下子来到了数据库,引起缓存雪崩

这个时候当业务端发现 redis 不可用,或者发现缓存雪崩(通常监控到数据库的请求量突增的情况)时,可以在业务层启动限流,让原来的 `10000/s` 请求量限制到 `1000/s`
这样数据库的压力与原来保持一致,可以避免缓存雪崩时数据库的性能被严重影响

### 缓存和数据库之间的数据一致性问题

将 redis 当做旁路缓存使用,只要涉及到数据的更新,就很容易出现缓存和数据库之间的一致性问题

旁路缓存的一致性保证了什么?

1. 如果缓存中有数据,则缓存中的数据必须和数据库里的数据保持一致
2. 如果缓存里面没有数据,则数据库里的数据必须是最新值

任何不满足上述两点的情况,都属于数据不一致的问题

### 读写缓存的数据一致性问题

对于 `读写缓存` 来说,有两种写回数据库的策略

1. 同步直写:写缓存时,也同步写数据库,两个都写入成功后才返回成功,保证数据的强一致性
2. 异步回写:写缓存成功后就返回操作成功,等缓存页被淘汰时,当做 `脏页` 刷入数据库

对于有强一致性要求的场景,就只能采用同步直写策略; 且业务端需要把写缓存和写数据库放到同一个事务里面操作; 通过事务的原子性保证要么全部写成功,要么全部失败回滚

对于 `只读缓存` 来说

如果有新增数据,就直接写入数据库,这样未命中缓存的请求就可以通过数据库拿到最新数据,并且写回缓存

如果有更新数据,则分两种策略:

1. 先删除缓存的数据,再更新数据库
2. 先更新数据库,然后再删除缓存的数据

![img.png](https://tva1.sinaimg.cn/large/008vK57jgy1h83hzqwf0hj30hg08a0tz.jpg)

1. 新增数据时,符合旁路缓存的一致性要求,不会产生一致性问题
2. 删改数据时,如果采用先删缓存,再删数据库

如果缓存删除成功,但是数据库更新失败; 后续的请求在缓存未命中的情况下,就会从数据库里面取到旧值

或者说线程 A 准备更新记录,如果刚把缓存的数据删除; 此时线程 B 读取数据缓存缺失,就会从数据库里面取到还没来得及更新的旧值,导致数据不一致

![img_1.png](https://tva1.sinaimg.cn/large/008vK57jgy1h83i0ab1nbj30j609iq4u.jpg)

3. 删改数据时,如果采用先删数据库,再删缓存的策略

如果数据库删除成功,缓存删除失败; 后续的请求直接命中缓存,取到旧数据

或者说线程 A 准备更新数据,刚刚把数据库里面的数据更新掉; 此时线程 B 读取数据命中缓存后直接返回,此时线程 B 读到的是线程 A 还没来得及更新的旧值,导致数据不一致问题再次发生

可以看到,在并发场景下,读写数据的数据一致性问题难以得到保障

### 如何解决读写数据库的数据一致性问题

无论写请求时更新还是删除,在操作缓存的时候,都进行删除操作,即使是更新数据

考虑两个并发线程 A,B 同时更新一条数据

1. A 先更新数据库,B 接着更新数据库,此时数据库里面记录的最新值是 B 的结果
2. 当 B 更新完数据库后,更新缓存里面的旧值后返回,B 完成请求
3. 此时 A 拿着自己从数据库里面刚更新的旧值,又把缓存里面 B 更新的新值给覆盖掉,此时产生了数据不一致问题

如果上述两个线程在更新数据库之后,都采用删除缓存的操作,就不会有数据不一致的问题产生

#### 更新缓存,或者更新数据库失败的场景,可以采用消息队列进行重试

首先将需要更新或者删除的数据发到消息队列里,然后更新或删除数据库或者缓存里面的数据,如果这个步骤失败了则从消息队里面取出消息进行重试

直到数据库和缓存的数据都已经更新完成之后,把消息队列里面的消息移除,避免重复消费

如果重试次数达到阈值,则直接向业务端返回报错

![img_2.png](https://tva1.sinaimg.cn/large/008vK57jgy1h83i027ep7j30j80b4ju1.jpg)

这个过程当中,仍然存在数据不一致的问题,只不过重试机制保证的是数据的最终一致性,无法保证数据的强一致性

#### 先删除缓存,再更新数据库

线程 A 准备更新数据,刚刚把数据库里面的数据更新掉; 线程 B 读取数据命中缓存后直接返回,此时线程 B 读到的是线程 A 还没来得及更新的旧值

如果是删除而不是更新操作,上面的线程 B 可能会把数据库里面的旧值继续写回缓存; 这样在线程 A 对缓存的更新操作完成之前,后续的并发请求仍然会从缓存里面读取到旧值

#### 延时双删 策略

为了尽可能避免 `先删除缓存,再更新数据库` 策略下的数据不一致问题

简单来说,就是在写数据库的前后,都执行一次缓存的删除操作,伪代码如下

```
redis.delete(key)
mysql.update(key)
sleep(n)
redis.delete(key)
```

其中有个关键点就是 `sleep(n)` ,这里的等待时间,是为了保证读请求结束后,写请求可以把读请求因为缓存缺失而写回缓存的脏数据给删除掉

问题是这个 `n` 值是一个很难确认的数值; 如果 `n` 值过大,则会导致后续的读请求可能继续读到脏数据; 如果 `n` 值过小,也可能导致发生脏读的请求还没写入缓存,此时写请求就结束了,接着发生脏读的请求又把脏数据写回缓存

**实际上延时双删是非常不靠谱的解决方案,因为这个 `sleep(n)` 的评估非常难,而且 `sleep(n)` 这一步本就不可避免的增大了链路的整体耗时**

如果非要采用 `先删除缓存,再更新数据库` 的策略,最好使用 `消息队列` 将第二次删除操作异步化

这样可以在不 **太** 影响链路整体耗时的情况下,借助 `消息队列` 的异步和重试机制,保证数据的最终一致性

#### 先更新数据库,再删除缓存

对于旁路缓存来说,采用的就是 `先更新数据库,再删除缓存` 的策略

但是不可避免也会存在数据不一致的问题

线程 A 更新数据库之后,还没来得及删除缓存时,线程 B 已经读取到缓存的旧值并返回

![img_3.png](https://tva1.sinaimg.cn/large/008vK57jgy1h83i0lmu3hj30j508q0wf.jpg)

## 总结: 无论是先删缓存还是先操作数据库,都存在数据不一致的问题

而先删缓存,在操作数据库,其最终结果可能连最终一致性都无法得到保障; 只能通过额外的步骤来保证数据的最终一致性,但是这样又引入了更高的系统复杂度

![img_4.png](https://tva1.sinaimg.cn/large/008vK57jgy1h83i0qo8aoj30k408qq4y.jpg)

可以看到,在线程 A 删除缓存之后, 线程 B 在 A 更新数据库之前已经读取到了旧值,并且还把旧值给写回缓存了; 这样后续的请求都只能读到缓存里面的脏数据; 数据的最终一致性没有得到保证

而先操作数据库,再删除缓存,能够保证数据的最终一致性

![img_5.png](https://tva1.sinaimg.cn/large/008vK57jgy1h83i0va75rj30kp0ahjtw.jpg)

可以看到当线程 A 更新数据库后,线程 B 从缓存里面读取到旧值返回,当线程 A 将缓存里面的旧值删掉后,下一个请求就会把数据库里面的最新值写回缓存; 就这样保证了数据的最终一致性

即使也有数据不一致的问题产生,但是先操作数据库,再删除缓存能够保证数据的最终一致性; 对于大部分能够不需要强一致性的业务来说,这就是最简单的解决方案

考虑一种特殊情况,如果某个数据刚好过期,或者缓存里面压根就没有

此时线程 B 先从数据库里面读到了旧值,接着线程 A 更新数据库然后删除缓存(即使没有也执行删除操作),最后线程 B 再把刚刚读到的旧值给写回缓存,这样后续所有请求都会读取到旧值,导致数据不一致问题产生

![img_6.png](https://tva1.sinaimg.cn/large/008vK57jgy1h83i0zoxtoj30l509ywgx.jpg)

在实际情况下,这要求线程 B 从数据库里读出旧值到写回缓存的这段期间时间长于线程 A 更新数据库后再删除缓存

更新数据库的时间通常比查询数据库的时间更长,而线程 B 仅仅是查询数据库,却反而比线程 A 更新数据还要花更长的时间; 这种概率非常小