---
title: (十二)redis 缓存问题
date: 2022-11-13 10:45:45
index_img: /img/redis.png
categories:
  - redis
tags:
  - redis
---

### redis 缓存所面临的问题

在高并发业务下,数据库往往是性能最为薄弱的环节; 所以使用 redis 放在业务和数据库之间,作为旁路缓存起到一个缓冲的作用,避免所有请求全部打到数据库; 这样可以大大的缓解数据库的压力

当 redis 作为旁路缓存使用时,就不得不考虑以下几个问题

1. 缓存穿透
2. 缓存击穿
3. 缓存雪崩
4. 缓存污染或者缓存写满(回顾下缓存的淘汰策略)
5. 缓存和数据库的一致性问题

### 缓存穿透

什么是 `缓存穿透`, 就是一个数据 **即不存在于数据库,也不存在于缓存里** ; 每次对这个数据的请求都不会命中缓存,而是直接发向数据库

由于数据库里面也没有,所以也不会回写到缓存里,导致缓存的存在失去了意义

在大量请求的场景下,如有有人恶意构造不存在的 `key` 从而发起攻击,很可能导致数据库压力过大

解决方案:

1. 业务层做校验,对于一些请求非法资源的,直接拦截掉; 例如 `id < 0`

实际上业务层无法做到对所有非法请求的拦截,只能过滤掉一些常规的明显的非法参数

2. 如果在缓存和数据库里面都查询不到数据,业务层可以回写一个空数据,即 `key-null` 到缓存里面; 这样下次对于这个不存在的 `key` 的请求,就可以由缓存快速返回空值 `null`

如果有大量不存在的 `key` 请求都通过这种方式在缓存里面写入了空 `key-null`,就会造成缓存的内存空间被浪费; 可以对这些 `key-null` 设置一个较小的过期时间 `10s`
之类的,避免缓存里面长时间被塞满空 `key-null` 键值对

3. 使用布隆过滤器

#### 使用布隆过滤器来减少缓存穿透的问题

布隆过滤器是一种 `概率型数据结构` ,用于在有限的内存空间内,快速判断一个元素是否存在于集合当中

为什么说是 `概率型` 因为布隆过滤器是基于统计判断的; 如果布隆过滤器说元素存在于集合当中,此时元素 **可能** 不存在(统计发生了偏差错误); 如果布隆过滤器说元素不存在于集合当中,此时元素 **一定** 不存在

布隆过滤器的基本数据结构其实就是一个 `bit 数组`,首先分配一块内存空间作为 `bit 数组` ,数组的每个位都初始化为 `0`

当有一个元素加入时,布隆过滤器使用 `K` 个互相独立的哈希函数计算得到 `K` 个不同的位置,然后把这 `K` 个不同的位置设置为 `1`

当需要检测一个元素是否存在于集合当中时,则仍然使用这些哈希函数计算得到对应的位置,判断这些位置上是否全部是 `1`,如果全部是 `1` ,则元素 `可能` 存在于集合当中; 如果有 `0` 出现,则元素 `一定` 不存在集合当中

![img.png](https://tva1.sinaimg.cn/large/008vK57jgy1h83cyg2hrbj30lm0cl424.jpg)

由于布隆过滤器使用哈希函数计算,不可避免会产生 `哈希碰撞`

即不同的元素经过哈希函数计算后,得到了相同的哈希值; 导致集合只有其中一个元素时,也会判断另一个元素存在

而且布隆过滤器存在几个比较致命的问题:

1. 不允许对布隆过滤器中的元素做删除操作
2. 当布隆过滤当中的元素增多时,其误判率会增大

因为存在 `哈希碰撞` 的问题,导致一个元素被删除后,将 `bit 位` 置 `0` 的时候会影响其他元素的哈希值; 因此导致布隆过滤也认为其他被影响到的元素不存在于集合当中

### 缓存击穿

什么是 `缓存击穿`, 针对热点数据的访问非常频繁,而缓存里面没有这条数据,导致大量请求在短时间内全部打到了数据库,因为数据库压力激增

什么情况会导致缓存击穿: 当某个热点数据过期后,被 redis 淘汰掉,此时大量请求会穿过 redis 直接来到数据库

![img_1.png](https://tva1.sinaimg.cn/large/008vK57jgy1h83cymyd61j30ho09i75x.jpg)

对于缓存击穿问题,解决办法也比较直接

1. 既然是由于热点数据过期导致未命中缓存,就直接把热点数据设置一个很长的过期时间直到大流量时间过去; 或者干脆设置热点数据永不过期
2. 缓存击穿是因为短时间内高并发请求透过缓存直接打到数据库; 针对高并发场景下,一个最原始最直接的办法就是 `加锁互斥串行化`

针对加锁,主要实现如下:

* 第一个拿到锁的线程查询数据库后,回写到缓存里
* 后面没拿到锁的线程全部排队等待锁
* 当第一个线程完成缓存回写之后,后续所有请求都会由缓存直接返回; 即使存在加锁和释放的过程也很短暂

### 缓存雪崩

什么是 `缓存雪崩`, 缓存击穿是一个 `key` 发生过期导致针对这个 `key` 的请求全部打到数据库; 而 `缓存雪崩` 就是短时间内, `大量` 的 `key` 发生过期,从而引发大量数据打入数据库,导致数据库压力激增

`缓存雪崩` 和 `缓存击穿` 一个很明显的区别就是: 击穿是针对一个 `key` 过期的大量并发请求; 而雪崩是大量 `key` 过期时的大量并发请求; 后者对业务的影响更为严重

#### 缓存雪崩的原因之一: 短时间内大量数据过期

很简单的一个场景,例如有一批热点短视频需要由运营发布上线,此时为了配合运营,开发人员使用批处理任务或者脚本将这批视频数据刷入缓存里面,由于是批处理任务所以这些视频数据被设置了相同的过期时间

当这个过期时间到达后,这批热点数据立马全部在缓存里面失效; 后续所有对这批数据的请求,将会全部直接打到数据库,引发缓存雪崩

![img_2.png](https://tva1.sinaimg.cn/large/008vK57jgy1h83cysg1ovj30hh09jwg9.jpg)

解决的办法也很简单,针对批量设置热点数据过期的问题,可以引入一个随机数,每次对数据设置过期时间 `expire` 时,都为其加上一个随机数 `random` 这样可以有效的解决相同过期时间到达后,大量数据的过期

除了添加随机过期时间,还可以从业务层面直接降级熔断

* 如果是非关键路径上的请求,则可以在业务层暂时快速失败,提前返回错误,控制或者预先准备好的预定义数据
* 如果是关键路径上的请求,则允许这部分请求先打到数据库; 这样可以减少直接进入数据的请求量; 当这些请求完成了缓存回写后,后续的请求依然可以通过缓存快速得到结果

服务限流也是一种有效手段,例如业务的请求量是 `10000/s` ,而其中 `9000` 个可以在 redis 处理直接返回,剩下的 `1000` 个只能由数据库提供支持

在某一时刻 redis 宕机不可用,此时大量 `key` 全部失效,导致请求压力一下子来到了数据库,引起缓存雪崩

这个时候当业务端发现 redis 不可用,或者发现缓存雪崩(通常监控到数据库的请求量突增的情况)时,可以在业务层启动限流,让原来的 `10000/s` 请求量限制到 `1000/s`
这样数据库的压力与原来保持一致,可以避免缓存雪崩时数据库的性能被严重影响