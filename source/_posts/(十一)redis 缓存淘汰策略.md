---
title: (十一)redis 缓存淘汰策略
date: 2022-11-12 20:21:06
index_img: /img/redis.png
categories:
  - redis
tags:
  - redis
---

### redis 的缓存淘汰机制

想要淘汰一个缓存,有两步关键的步骤

1. 通过一定的策略,选出 **需要被淘汰** 的缓存
2. 在合适的时机,将这些缓存从内存里删除

一旦 redis 实例配置好整体缓存的大小之后,除非是只读缓存否则总会发生缓存被写满的那一刻

而淘汰缓存就必须要解决上面两个问题:如何选?什么时候删?

### redis 缓存淘汰策略(解决如何选问题)

redis 在 4.0 以后提供了 8 种缓存淘汰策略

1. 不进行缓存淘汰,只有 `noeviction` 这一种 (通常也没有人会选择这种策略)
2. 会进行缓存淘汰的其他 7 种策略还可以按照两类进行划分
   * 设置了过期时间的数据
   * 所有范围内的数据

#### 设置了过期时间数据的淘汰策略

1. volatile-ttl: 在筛选时,针对设置了过期时间的键值对,根据过期时间的先后进行删除,越早过期的数据越早被删除
2. volatile-random: 在筛选时,针对设置了过期时间的键值对,随机选出若干数据进行删除
3. volatile-lru: 在筛选时,针对设置了过期时间的键值对,使用 `LRU` 算法选择需要淘汰的数据
4. volatile-lfu: 在筛选时,针对设置了过期时间的键值对,使用 `LFU` 算法选择需要淘汰的数据

#### 所有数据的淘汰策略

1. allkeys-random: 针对所有数据随机选择并删除
2. allkeys-lru: 针对所有数据,使用 `LRU` 算法选择需要淘汰的数据
3. allkeys-lfu: 针对所有数据,使用 `LFU` 算法选择需要淘汰的数据

需要注意的是,如果 redis 配置的是针对所有数据的淘汰策略; 那么按照策略选出来的数据即使还没有到过期时间,也会被淘汰掉


### LRU 算法

`LRU` 算法即 `最近最少使用` , 可以把一段时间内最不常用的数据筛选出来,而那些频繁被访问的热数据则会继续留在缓存里面

`LRU` 会把所有缓存页组织为一条链表,表头是 `MRU端` 表尾是 `LRU端`

![img.png](https://tva1.sinaimg.cn/large/008vK57jgy1h83ayzqhv2j30ih0iijvw.jpg)

当 `LRU` 缓存里面有数据被命中了,则会被放置到表头; 而那些迟迟没有命中的数据则会随着时间推移慢慢来到表尾

当 `LRU` 被放满,而新的请求数据不在 `LRU` 里面,此时 `LRU` 发生了缺页就会从磁盘里面加载最新的数据页放到表头; 这样处于表尾的冷数据就会被淘汰掉

朴素的 `LRU` 根据局部性原理,认为当前被访问的数据接下来还会访问的概率会很大,所以直接放到表头; 而 `LRU` 当有大量数据被访问时(类似 mysql 全表扫描导致 `buffer pool` 缓冲区污染的问题),会带来很多链表节点的移动操作,此时可能会导致 redis 性能下降

redis 在朴素 `LRU` 算法上进行了一些改良,并没有通过传统的链表组织数据

redis 会记录每个数据的最近一次访问时间戳(由 redis 的抽象数据结构 `redisObject` 记录),这个字段记为 `lru` 值

当 redis 需要淘汰数据时,首次会根据配置一次性选出 `N` 个数据放到一个集合里面; 接下来 redis 会比较这 `N` 个数据的 `lru` 值,把最小 `lru` 值的数据淘汰出去

后续再次需要进行数据淘汰的时候,redis 会把需要淘汰的数据加入到第一次淘汰时的集合里面去; 这里能够进入淘汰集合的要求是: `能进入淘汰集合的数据的 lru 字段必须必集合里面的最小 lru 值还要小`

当淘汰集合放满之后,redis 就会把集合中 `lru` 最小的数据淘汰出去

这样 redis 就不用维护一个所有数据的链表,也不用每次移动链表节点,只需要比较 `redisObject` 的 `lru` 字段即可, 提升了缓存的性能

* 如果系统有明显冷热数据的情况,优先选择 `allkeys-lru` 策略
* 如果系统没有明显的冷热数据区分,选择 `allkeys-random` 进行随机淘汰就可以
* 如果系统有 **置顶** 等要求,则选择 `volatile-lru` 策略,并且将这些置顶的数据设置为永不过期

### 如何删除被淘汰的数据

与 mysql 的 `buffer pool` 淘汰缓存页类似,同样 redis 也将缓存页分为 `干净页` 和 `脏页` 

* 如果需要淘汰的是一张 `干净页` ,那么直接从内存里面出删除即可

* 如果淘汰的是一张 `脏页` ,那么从内存删除前还需要把脏页刷入数据库之后才能删除