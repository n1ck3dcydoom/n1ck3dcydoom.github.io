---
title: (二)mysql 事务隔离原理
date: 2022-11-03 09:21:13
index_img: /img/mysql.png
categories:
  - mysql
tags:
  - 数据库
---

## 数据库事务的四大特性

1. 原子性:事务里一组操作要么全部成功,要么全部失败,不会出现一半成功一般失败的情况
2. 持久性:事务一旦提交后,其变更就会永久保存下来,即使发生宕机也不会出现数据丢失的情况
3. 隔离性:不同的事务在并发提交时,其表现的结果看起来是串行化操作的结果
4. 一致性:数据保证数据从一个正确的状态转移到另一个正确的状态

一致性难以理解:它为数据库提供了一种 **约束** ,就是说每时每刻数据库都按照正确的方式运行

比如说我们约定某个字段不能等于 0,那么当我们执行插入 0 值,或者更新为 0 值时,数据库就不允许这种操作发生,因为违反了一致性

### 事务的隔离级别

1. 读未提交:最低的安全级别,事务当中还没有提交的改动能够被其他事务观察到
2. 读已提交:一个事务的操作只有提交之后才能被其他事务观察到
3. 可重复度:一个事务在执行过程中看到的数据,总是跟这个事务启动前的结果保持一致
4. 串行化:所有的事务通过 **加锁** 完成同步操作,出现竞争时必须等待其他事务释放锁资源

假设数据库只存在一条记录,事务启动前值为 1

![img_3.png](https://tva1.sinaimg.cn/large/008vK57jgy1h7rofspyx5j309205ugm5.jpg)

1. 读未提交时: 事务 A 的 v1 值已经可以查询得到 2,因为这个级别下可以观察到其他未提交事务发生的改动,所以 v1 = v2 = v3 = 2

2. 读已提交级别时: 事务 A 的 v1 值仍然是 1,因为这个级别下只能观察到其他已经提交事务的改动,而 v1 时事务 B 还没有提交,所以事务 B 的改动事务 A 并不能观察到

当事务 B 提交后, v2 = v3 = 2

3. 可重复度:先说结论,v1 = v2 = 1, v3 = 2

可重复度保证了事务在执行过程中观察到的数据和其执行前保持一致,对于事务 A 来说,启动事务前观察到值为 1,那么在执行事务过程当中,再去观察仍然还是得到 1

只有当事务 A 提交后,再去查询才能得到 v3 = 2

4. 串行化,由于事务 A 先查询值,所以当事务 B 更新值的时候,必须等待事务 A 执行完成之后才能继续操作

所以 v1 = v2 = 1, v3 = 1

### 快照

在实际数据库查询时,会创建一个 **视图** ,其作用可以理解为启动前所有数据的一个 **快照** ,并且这个 **快照** 在整个事务的执行过程中,不会被其他事务影响到

1. 读未提交:没有快照,直接读取数据的上一个最新状态
2. 读已提交:每次执行 sql 前,创建快照
3. 可重复度:每次事务启动前,创建快照
4. 串行化:没有快照,通过加锁保证穿行操作

### mysql 具体的隔离级别是如何实现的 以 **可重复读** 为例

mysql 在每条记录发生操作之前,都会提前记录一个 **回滚段** 的日志 也被称为 `undo log` ,充分体现了 mysql 写前日志的特性,任何数据发生改变前,都要先记录日志

这个 undo log 类似于一条链表,记录了数据每个发生变更时的上一个状态

![img_4.png](https://tva1.sinaimg.cn/large/008vK57jgy1h7rofzj9dkj30h4078abq.jpg)

通过回滚操作,当前值 4 的状态可以回滚到之前记录过的任何一个状态

对于这条记录,处于不同时刻创建的事务,事故观察到的记录的状态均不一样

对于事务 A,B,C 来说,他们在启动时观察到的记录的值分别为 1,2,4, 这个特性就是 mysql 的 **MVCC(多版本并发控制)**

同时根据视图快照的特性,对于视图 B 来说,如果有其他事务正在操作记录变更为 5,事务 B 也观察不到视图外面的改动

**注意,为什么说尽可能避免长事务,就是因为有 undo log 的存在,可能导致回滚链路非常长,造成磁盘空间的浪费**

详细说明一下这个 undo log 的组成

![img_5.png](https://tva1.sinaimg.cn/large/008vK57jgy1h7rog6bdhhj30tw02ngmn.jpg)

![img_6.png](https://tva1.sinaimg.cn/large/008vK57jgy1h7rogb06x9j30fq02vt8z.jpg)

第一部分主要是 undo log 记录的数据变更的具体信息等,用于回滚时反向操作数据用

第二部分则是构成回滚链的关键点,包含两个值

1. trx_id: myslq 会为每一个事务分配一个 long 类型的唯一 id,这个 id 是递增的
2. roll_point: 这是一个只想 undo log 类型的指针,指向上一个旧数据版本的 undo log

对于一个事务(trx_id = 10)来说,在某一时刻操作数据,就会产生一条 trx_id = 10,且 roll_point 指向上一个数据的 undo log

![img_7.png](https://tva1.sinaimg.cn/large/008vK57jgy1h7rogfsah8j30ie05wgmn.jpg)

若紧跟后面的事务(trx_id = 18)也访问这条数据,那么就会产生一条 roll_point 指向 trx_id = 10 的 undo log

![img_8.png](https://tva1.sinaimg.cn/large/008vK57jgy1h7rogkelk4j30ia07640c.jpg)

对于事务 A 来说,他是观察不到事务 B 的任何操作的

### 视图(快照)

再有了 undo log 日志链之后,myslq 基于 undo log 实现了另一种数据结构 **视图** 也可称为 **快照**

视图主要包含以下几个变量:

1. 创建视图时,当前正处于活跃状态的事务(即还没有提交的事务) ids 集合
2. 活跃事务 ids 集合里面最小的事务 id, `min_id`
3. 活跃事务 ids 集合里面 **下一个要生成的事务** id,即当前 ids 里面最大的事务 id + 1, `max_id`, 这样下一个事务 id 一定比当前所有活跃事务的 id 都要大
4. 创建当前视图的事务 id, `created_trx_id`

其中 `min_id` 也称为 `低水位`, 同理 `max_id` 称为 `高水位`

现在使用两个事务 A,B 来模拟可重复读场景下, 视图是如何工作的; 假设事务 A 在提交之前反复读取数据; 事务 B 在提交之前修改数据

#### 快照读

此时事务 A 创建时,有两个事务正处于活跃状态,id=10 和 id=18

自然事务 A 此时创建的视图数据:ids=[10,18], min=10, max=18+1=19, created_trx_id=10

还记得之前说过的吗,每条记录被写之前,都会产生一条 undo log,用于记录数据的旧值

此时事务 A 访问记录,将事务 A 指向最新的 undo log,里面保存了最后一个访问记录的状态,假设最后一个访问记录的事务 id = 8,此时的 undo log 如下

![img_9.png](https://tva1.sinaimg.cn/large/008vK57jgy1h7rogpfk8aj30iz04emyi.jpg)

事务 A 的 undo log 保存的最后一个访问记录的事务 id = 8,意味着什么

之前也说过,myslq 会为每个创建出来的事务分配一个 long 类型的事务 id 即 trx_id ,这个 id 随着时间先后顺序依次递增

当前事务 A 的 trx_id = 10,而 undo log 里面记录的最后一个事务的 trx_id = 8

这说明这条记录是在事务 A 创建之前就已经提交过的了,自然 事务 A 是能够访问到这条记录的值 X

此时,事务 B 启动,并且去更新记录的值为 B,这个时候由于写操作产生,会提前记录一条 undo log

其内容很好分析,创建 undo log 的 trx_id 等于操作的事务 trx_id 即 18,且 undo log 的回滚指针 roll_point 指向上一个旧数据,也就是值 X 时的记录

![img_10.png](https://tva1.sinaimg.cn/large/008vK57jgy1h7rogum90bj30if07zmyz.jpg)

此时,在事务 B 更新了数据之后,事务 A 再次去查询记录,发现 undo log 链路上有最新的节点,即 trx_id = 18 的记录

但是事务 A 并不能立马认为记录就被更新为 B 了,因为它还需要根据快照里面保存的内容去判断这条更新操作究竟能不能够被它访问到,过程如下

1. 事务 A 发现最新记录 undo log 里面更新的事务 trx_id = 18
2. 事务 A 查询自己的视图里面的活跃事务 ids 集合,发现有 trx_id = 18 的记录存在
3. 这说明事务 A 创建视图的时候,trx_id = 18 的事务跟自己一样处于活跃状态,也就是 **未提交** 状态
4. 这个时候的记录 B 是由未提交的其他事务产生的,在当前视图下是不可观察到的
5. 所以事务 A 根据 undo log 的 roll_point 查看上一个旧的记录,发现 trx_id = 8,小于自己的低水位
6. 说明 trx_id = 8 的记录是由已经提交的事务产生,在当前视图下是可以观察到的
7. 最终事务 A 第二次查询记录得到的值仍然是 X

简单总结如下:
* 如果 trx_id 小于低水位,表示这个版本在事务启动前已经提交,可见
* 如果 trx_id 大于高水为,表示这个版本在事务启动后生成,不可见
* 如果 trx_id 大于低水位,小于高水位,分为两种情况:
1. 若 trx_id 在数组中,表示这个版本在事务启动时还未提交,不可见
2. 若 trx_id 不在数组中,表示这个版本在事务启动时已经提交,可见

这就通过视图实现了可重复读的效果

#### 当前读

来看另一种情况,在可重复读级别下会发生什么

假设有 A,B,C 三个事务按照下图所示的方式操作数据

![img_11.png](https://tva1.sinaimg.cn/large/008vK57jgy1h7rogzt3naj30fa0afwf7.jpg)

假设此时 A,B,C 三个事务创建时,活跃的事务只有 trx_id = 99,那么此时的快照分别如下:

![img_12.png](https://tva1.sinaimg.cn/large/008vK57jgy1h7roh4s1lyj30et06ogo5.jpg)

首先分析 A:
1. get K 时,发现 k 的 undo log 指向数据为 (1,3) 的版本,且 trx_id = 101
2. trx_id = 101 大于事务 A 的高水位 100,说明这个版本不可见,往上查找 undo log
3. trx_id = 102 大于事务 A 的高水位 100,同样不可见,继续网上查找 undo log
4. trx_id = 90 小于事务 A 的低水位,可见,此时事务 A get k 的结果为 (1,1)

接着分析 B:
1. set K 时,创建新的 undo log,其 trx_id = 当前更新数据的事务 id 101

当按照一致性读的时候,写入 k 之前肯定要得到 k 的值,这里问题来了

事务 B 的高水位为 101,写入 k 之前的 undo log 版本为 102,此时是高于 B 的高水位的

也就是说如果按照一致性读来解释的话,B 应该只能拿到 90 版本的值 (1,1) ,从而在写之后更新版本 101 的值为 (1,2)

思考一个问题: C 在 B 之前已经更新了 k 值为 (1,2) 如果此时 B 按照一致性读取更新 K 值为 (1,2) 会导致 C 的更新丢失了

为了解决这个问题,mysql 引入了一个新的概念: **当前读**

其含义就是: 所有的更新操作都是 **先读后写** ,而这个 **读** 必须是读取 **当前最新的值** ,不然以前的修改就会丢失

所以根据 **当前读** ,B 在更新 k 的时候,是已经能够拿到 C 的操作,所以 B 写入数据版本 101 的值为 (1,3)

随后 B 执行 get K 操作,一看当前最新的 undo log 的 trx_id = 101 是自己,那当然可以读取到了

即,一个事务里面,之前发生过的更新操作,之后的查询操作一定能够观察到(自己写的数据自己认)

#### 两阶段锁协议

考虑事务 C 修改为如下

![img_13.png](https://tva1.sinaimg.cn/large/008vK57jgy1h7rohbk3gnj30fc09gdgm.jpg)

虽然事务 C 在事务 B 之前发起了更新操作,但是并没有立即提交,而是在事务 B 的更新操作之后才提交的

此时事务 B 会如何处理呢

由于事务 C 的 update 操作会为当前数据加上写锁,而事务 B 根据当前读原则,要求其更新数据时必须是当前的最新数据

但是当前数据上的写锁仍然被其他事务持有,所以事务 B 不得不等待事务 C 释放写锁后才能读取到事务 C 的最新改动,从而更新值

#### 总结

总结来说

可重复读的本质就是通过 **视图** 达到 **一致性读**

但是在遇到更新操作是,就必须通过 **当前读** 来保证之前的更新不会丢失

如果更新的记录被其他事务持有写锁,根据 **当前读** 原则,必须等待其他事务释放写锁后,才允许继续更新记录
