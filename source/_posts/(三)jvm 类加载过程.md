---
title: (三)jvm 类加载过程
date: 2022-11-15 15:41:43
index_img: /img/java.png
categories:
  - jvm
tags:
  - jvm
---

### java 的类文件结构

不同于 `json` `xml` 之类的描述性语言,类文件是以纯粹的二进制字节流构成,哪些位置的哪些字节数代表的含义都是确定的,包括先后顺序之类的都不允许发生改变

按照顺序如下:

* java 魔数,前 4 个字节固定 `0xCAFEBABE`
* 类文件版本号,高版本号的虚拟机可以向下兼容编译低版本号的类文件,而低版本号的虚拟机无法编译高版本号的类文件,会直接报错
* 常量池入口
* 访问标志,标明一个类文件是 `类` 还是 `接口`,也记录了是否是 `public` 以及 `final` `abstract` 等修饰符
* 类索引,父类索引,接口索引,用于记录继承的父类,实现的接口等等信息
* 字段表集合: 包括类或者接口声明的各种变量信息
* 方法表集合: 包括类或者接口声明的各种方法信息
* 属性表集合: 用于描述方法或者变量的各种额外信息,包括抛出的异常等等

### 类加载机制

#### 类加载过程

1. 加载
   * 通过类的全限定名获取类的二进制字节流
   * 将字节流里面的数据解析为方法区当中的运行时数据结构
   * 生成一个 `Class` 对象通过反射为类的各种变量设置访问入口
2. 验证
   * 验证字节流里面的数据都是符合安全规范的,对于不安全的数据直接拒绝进行类加载
3. 准备
   * 为类里面的静态变量进行内存分配,以及初始化
4. 解析
5. 初始化
   * 变量在分配时已经设置了初始值
   * 调用构造方法为变量设置默认值
   * 父类静态代码块 > 父类静态变量 > 子类静态代码块 > 子类静态变量 > 父类构造方法 > 子类构造方法
6. 使用
7. 卸载

#### 类加载器

`通过类的全限定名获取类的二进制流` 执行这个工作的代码被称为 `类加载器`; 每个 `类加载器` 都有自己的命名空间,对于类的比较都必须基于同一个命名空间; 即使同一个类,但是通过不同的 `类加载器` 加载,这两个类也是不相同的

#### 双亲委派模型

对于 jvm 来说,只有两类类加载器

`启动类加载器 BootstrapClassLoader` 这个由 C++ 实现,是虚拟机的一部分

`应用自定义类加载器` 这个由 java 实现,不属于虚拟机的一部分

对于开发者来说,分为好几种类加载器

1. `启动类加载器 BootstrapClassLoader`: 负责加载 `JAVA_HOME/lib` 目录下的类文件或者 `-Xbootclasspath` 指定的类文件
2. `扩展类加载器 ExtensionClassLoader`: 负责加载 `JAVA_HOEM/lib/ext` 目录下的类文件,这里面都是一些扩展类库
3. `应用程序类加载器 ApplicationClassLoader`: 负责加载用户目录 `CLASS_PATH` 目录下的类文件; 开发者可以直接使用这个类加载器,如果一个类没有指定加载器 jvm 也会为其配置默认的应用程序类加载器

![img.png](https://tva1.sinaimg.cn/large/008vK57jgy1h85xur73yzj30g90f1gnl.jpg)

这种层次关系,被称为类加载器的 `双亲委派模型`: 要求除了顶层的启动类加载器以外,其他所有加载器都必须有自己的父加载器,且最后都是以启动类加载器为终点

`双亲委派模型` 的工作流程: 当一个类加载器收到一个加载请求时,并不会立即加载,而是会交给自己的父加载器处理,只有当父加载器明确告知无法加载时,才会由当前类加载器尝试进行加载

这样的好处就是每个类都随着类加载器而被赋予了一种带有优先级的 `层次关系`

例如 `java.lang.Object` 无论哪个类加载器加载 `Object` 对象时,都会委派给自己的父加载器,由于这个类存放于 `JAVA_HOEM/lib` 目录下,所以最终会由顶层的启动类加载器进行加载

这样所有的 `Object` 类都来自于顶层的启动类加载器,保证在各种环境下 `Object` 类都是同一个类
