---
title: (十一)mysql 幻读和 next-key lock
date: 2022-11-06 14:11:53
index_img: /img/mysql.png
categories:
  - mysql
tags:
  - 数据库
---

## 什么是幻读

幻读的定义: 事务在执行过程前后两次查询同一个范围内的数据时,后一次读到了前一次没有读到的结果

在可重复度级别下,普通的查询时 **快照读** 是不会观测到其他事务在其中插入的数据的,因此 **幻读** 仅发生在 **当前读** 的操作下

### 幻读带了什么问题

假设有如下三个会话,并且没有针对幻读采取任何措施

且表里面只有 2 条记录 `id = 5, d = 5`, `id = 0, d = 0`, 执行顺序如下

![img.png](https://tva1.sinaimg.cn/large/008vK57jgy1h7vflq7ab8j30rz0f1grs.jpg)

从语义上来说,会话 A 开启了 **当前读** ,所以三次 `select` 查询得到不同的结果,在这个场景下看起来是符合语义的,当前读就是能看到其他未提交会话的更新操作

如果会话 A 在 T1 时刻查询后执行了一次 `update` 操作 `update t set d = 100 where d = 5`

由于会话 B 和 C 都是执行一条 sql 语句,会在执行完成后立马提交事务,而会话 A 因为是通过 `begin` 开启的事务,所以必须在显式声明 `commit` 后才会提交事务,那么 `binlog` 的记录会是什么样的呢

```sql
-- 会话 B
update t set d = 5 where id = 0    -- (0,0,5)

-- 会话 C
inserst into t values(1,1,5)       -- (1,1,5)

-- 会话 A
update t set d = 100 where d = 5   -- (5,5,100) (0,0,100) (1,1,100)
```

如果使用这份 `binlog` 去做主备同步或者备份数据库的话,会导致 `id = 0 和 id = 1` 的数据发生不一致的现象

很明显,会话 A 的 **当前读** 语义上是要对所有 `d = 5` 的数据加上锁,但是后来发现会话 B 将原来 `d != 5 的 id = 0` 的记录给更新为 `d = 5`,而且会话 C 更是插入了一条 `id = 1 且 d = 5` 的数据,这根原来会话 A 给 `d = 5` 加锁的语义发生了冲突

显然会话 A 并没有为所有 `d = 5` 的记录加上行锁,仅仅是锁住了 `id = 5, d = 5` 这一行数据; 如果进一步假设锁的范围变得更加严格,让所有被扫描过的 `d = 5` 的记录加上行锁

![img_1.png](https://tva1.sinaimg.cn/large/008vK57jgy1h7vflvnhywj30lb0990vu.jpg)

但是对于会话 C 呢,由于 `id = 1` 的记录之前并不存在所以自然而言也没有对 `id = ` 的记录加锁,所以会话 C 仍然能够执行,此时 `binlog` 日志记录如下:

```sql
-- 会话 B 被阻塞,
-- update t set d = 5 where id = 0    -- (0,0,5)

-- 会话 C 因为 id = 0 的记录不存在,自然也没有锁,能够正常插入
inserst into t values(1,1,5)       -- (1,1,5)

-- 会话 A
update t set d = 100 where d = 5   -- (5,5,100) (0,0,0) (1,1,100)

-- 会话 B 在会话 A 提交后才能得以更新
update t set d = 5 where id = 0    -- (0,0,5)
```

显然,会话 B 的问题解决了,但是会话 C 的问题还没有解决

可以看到给单独的行加上行锁,或者给扫描过行加上行锁,在 **当前读** 的场景下都无法解决幻读的问题

### 如何解决幻读

InnoDB 引入 `间隙锁` 的概念来解决行锁,先说下 `间隙` 是什么

对于上面的表,只有两条记录的时候 `id = 0, d = 0` 和 `id = 5, d = 5`, 此时把主键 id 放到一条数轴上,有如下表示:

![img_2.png](https://tva1.sinaimg.cn/large/008vK57jgy1h7vfm2gsxnj30fa03cjrd.jpg)

InnoDB 规定 `间隙` 的区间端点为 `左开右闭` ,对于正无穷为了让右区间为闭区间,InnoDB 约定了一个固定的最大值

对于 `间隙` 上面的加锁,就叫做 `间隙锁`

在有了 `间隙锁` 之后,会话 A ,就会为数据两边的 `间隙` 都加上 `间隙锁`,如下图所示

![img_3.png](https://tva1.sinaimg.cn/large/008vK57jgy1h7vfm95entj30om08awfj.jpg)

可以看到当会话 A 查询 `id = 3` 的记录时 `for update` 不仅仅为当前记录加锁,还把周围的间隙也加上了锁; 这样会话 B 在这个间隙里插入记录的时候会被阻塞掉

### 间隙锁和死锁问题

考虑如下场景

![img_4.png](https://tva1.sinaimg.cn/large/008vK57jgy1h7vfme14t9j30rl0ah76b.jpg)

对于会话 A,锁住的间隙是 `(5,max]`, 对于会话 B,锁住的间隙也是 `(5,max]`,可以看到同一个间隙锁可以被多个会话同时加锁,它们之间并不互斥,与间隙锁发生互斥的条件仅仅是 **往间隙当中插入新数据** 

紧接着会话 B 插入数据,由于会话 A 持有了间隙锁,所以会话 B 被阻塞

同理会话 A 插入数据时也因为间隙锁导致阻塞,这里 mysql 的主动死锁检测立马就会返回报错

### 总结

InnoDB 如何解决幻读问题

* 对于快照读, `MVCC` 可以保证幻读不会产生
* 对于当前读, `间隙锁` 保证幻读不会产生