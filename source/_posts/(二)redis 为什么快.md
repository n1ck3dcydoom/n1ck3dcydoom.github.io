---
title: (二)redis 为什么快
date: 2022-11-10 08:38:07
index_img: /img/redis.png
categories:
  - redis
tags:
  - redis
---

### redis 使用单线程

1. 完全基于内存,绝大部分请求都是在内存中计算处理,少量需要持久化的操作才会涉及到写磁盘
2. 数据结构是专门设计的,操作简单
3. 单线程,省去了线程间的上下文切换和 CPU 消耗,不存在资源竞争,不涉及加锁和释放的操作

这里的单线程指的是 **处理网络 IO 请求和键值对读写(核心工作线程)** 是单线程的,而对于那些需要持久化的操作,例如写日志,异步删除,集群间节点数据同步等是有额外线程执行的

### IO 多路复用

#### select 模型

将所有已连接的 `socket` 都放入一个 **文件描述符集合** 当中,调用 `select` 函数把这个集合拷贝给内核,让内核轮训集合检测是否有网络事件

而内核检测是否有网络事件产生的方式则是通过遍历每个文件描述符,如果有网络事件产生,则将此 `socket` 标记为可读或者可写,遍历完成后把这个集合再拷贝回用户态交给 `select` 函数处理

此时用户态还需要做 **第二次** 遍历,才能找到就绪的 `socket` 并且进行处理

可以看到 `select` 模型有如下特点:

1. 需要遍历 2 次文件描述符集合
2. 发生 2 次用户态到内核态,内核态到用户态的拷贝

而且操作系统在不修改配置的情况下,默认只允许一个进程最大操作 `1024` 个文件描述符

#### poll 模型

几乎与 `select` 一样,仅仅是使用链表来组织 **文件描述符集合** ,突破了 `select` 最大监听数量而已

#### epoll 模型

1. 使用 **红黑树** 存储文件描述符集合
2. 使用 **就绪队列** 存储就绪的文件描述符
3. 每个文件描述符只需要在添加时传入一次,通过事件更改描述符状态

`select, poll` 都只有一个相关函数,而 `epoll` 有 3 个相关函数 

`epoll_create()`

创建一个 `epoll` 实例,其内部主要有两个结构:
* 监听列表: 所有需要监听的文件描述符集合,使用 **红黑树** 存储
* 就绪列表: 监听列表里面已经就绪的文件描述符结合,使用 **队列** 存储

`epoll_ctl()` 

监听文件描述符 `fd` 上发生的 `event` 事件

调用 `epoll_ctl()` 函数会将当前文件描述符 `fd` 添加到 `epoll` 实例的监听列表里面,同时为 `fd` 设置一个回调函数,并且监听指定的 `event` 事件; 当 `fd` 上发生指定事件 `event` 之后,就会调用回调函数将 `fd` 放入 `epoll` 实例的就绪列表里面

`epoll_wati()`

`epoll` 模型的主要处理函数,起作用相当于 `select`,当调用 `epoll_wait()` 时,会返回 `epoll` 实例的就绪列表里面的描述符个数,避免 `select, poll` 每次遍历所有集合元素

#### 水平触发

当监听到文件描述符就绪后,就会触发通知,如果当前文件描述符缓冲区内的数据没有处理完,下次遍历到的时候还会继续发出通知

#### 边缘触发

仅当文件描述符从未就绪变更为就绪时,触发一次通知,且之后不会再次通知; 这要求处理函数必须在通知到来时,将缓冲区内的数据通过循环全部处理完成

边缘触发可以减少 `select` 的调用次数,只不过在一次调用当中需要反复调用多次 `read` 

`epoll` 采用边缘触发的方式,保证每次调用 `epoll_wait()` 都是有效的,因为一次调用必须把缓冲区内的所有数据全部处理完才能返回,否则内核会认为就绪的文件描述符的状态没有发生改变(还有数据没处理完,仍然是就绪状态),从而不再发出后续的通知导致内容丢失

#### redis 的 IO 多路复用

redis 将监听套接字的工作交给内核完成,而内核采用 `epoll` 的机制同事监听多个套接字和管理已就绪的套接字; 一旦有请求到来,通过就绪队列可以快速的找到文件描述符,交给 redis 的 IO 进程处理

这样 redis 就实现了一个 IO 进程复用,处理多个网络请求的效果

![img.png](https://tva1.sinaimg.cn/large/008vK57jgy1h7zrs431btj30io0chq61.jpg)

可以看到,redis 的 IO 进程其实就是在不断的处理 `epoll_create` 创建的 `epoll` 实例的就绪队列,每个就绪的文件描述符因为有 `epoll_wati` 的调用,都记录了监听的事件和对应的回调函数

当 redis 的 IO 进程拿到就绪的文件描述符之后,可以直接调用对应的回调函数进行请求的处理; 并且不会阻塞在某一个请求上,而是可以继续处理队列里下一个就绪的请求

