---
title: (六)redis 切片集群
date: 2022-11-11 20:46:21
index_img: /img/redis.png
categories:
  - redis
tags:
  - redis
---

### redis 的单机部署

考虑如下情况,假如有一批数据预估在 `25G` 左右,此时应当选用什么样配置的 redis 来保存这批数据

通常情况下,redis 的机器内存要超过数据量才够,此时选用一台 `32G` 的服务器,还能有剩余 `7G` 来做 redis 持久化,持久化的方式选为 `RDB` 快照

可实际情况并不令人满意,在 redis 实例正常运行一段时间之后,开始变得缓慢起来,很容易想到是在做 `RDB` 快照的时候造成了性能问题

每当需要 `RDB` 快照的时候,主线程都会 `fork` 一个子线程去后台专门做快照,然而在 `fork` 的过程当中,需要复制主线程内的所有内存数据,足足有 `25G` 之大

显然此时的 `fork` 操作阻塞了主线程的正常运行,需要更换 redis 的部署方式

### redis 的切片集群

相对于上面的单机部署来说,很容易想到集群化,将 `25G` 的数据平均分为 5 个 `5G` 大小的切片,将这个 5 个切片分别部署在 5 台 redis 实例上

这样每个 redis 实例所需要的服务器资源也变少了,而且 `RDB` 快照时需要复制的内存数据页变小了,`fork` 操作对主线程的影响几乎没有

![img.png](https://tva1.sinaimg.cn/large/008vK57jgy1h81m0nccsvj30j409x76v.jpg)

### 扩容方式

一般来说常见的扩容方式分为以下两种

1. 纵向扩展: 每次增加单机的配置; 例如单机 `10G` 增加到单机 `50G` ,或者增加单机内存,或者更换单机更好的 CPU,都属于纵向扩展
2. 水平扩展: 每次增加一台与之前完全相同配置的 redis 实例来组成一个复杂的 redis 集群

![img_1.png](https://tva1.sinaimg.cn/large/008vK57jgy1h81m0s34nkj30iu09agnh.jpg)

#### 纵向扩展

优点

1. 扩展时比较方便,实施简单

缺点:

1. 单机内存过大时,一次全量的 `RDB` 操作在 `fork` 时会阻塞主线程更长的时间
2. 从 `16G` 扩为 `32G` 很便宜,但是从 `512G` 扩容到 `1T` 其成本将会非常高

#### 横向扩展

为了避免纵向扩展的两个问题,又要保存更多的数据,只能通过增加 redis 实例的数量来实现

在面对千万级, 亿级数据的时候,集群化部署 redis 是非常合适的选择

缺点:

1. 数据切片之后,该如何分配到不同的 redis 实例上
2. 客户端如何确认自己要查询或者更改的数据在哪个 redis 实例上

### redis cluster 技术

在 redis 3.0 之后,官方提供了 `redis cluster` 技术来实现切片集群

#### redis cluster 哈希槽分配

具体来说,`redis cluster` 技术采用 `hash slot` 哈希槽来处理数据和实例之间的映射关系

在 `redis cluster` 方案当中,一共提供了 `16384` 个槽位用于存放数据; 每个保存在 redis 里面的键值对; 都会根据其 `key` 值被映射到一个唯一的哈希槽里面存放 `value`;
具体的哈希算法是将 `key` 通过 `CRC16` 校验后得到一个 `16bit` 的值,再把这个值和 `16384` 取模,最后得到的结果就是具体的哈希槽

在创建 redis 集群的时候,redis 会自动的把 `16384` 个哈希槽平均分配到每个实例里面; 若有 `N` 个实例,则每个实例存储的哈希槽个数为 `16384/N`

当然也可以通过配置,手动决定哪些实例保存哪些哈希槽

通常来说如果 redis 集群每个实例的配置有所不同,如果 `key` 都是均匀访问,那么配置低的实例面临的压力会明显大于配置高的实例,此时就需要手动分配哈希槽; 如果每个实例的配置一样,那么 redis 自动分配就更加简单

需要注意的是: 如果手动分配哈希槽,则需要所有 `16384` 个槽位全部分配完,否则 `redis cluster` 无法正常工作

![img_2.png](https://tva1.sinaimg.cn/large/008vK57jgy1h81m0wakvmj30iz09lwh3.jpg)

#### 客户端如何查询

当完成数据到哈希槽的分配,哈希槽到实例的分配之后,客户端如何得知自己需要访问的数据应该请求哪个具体的实例呢

首先数据到哈希槽的映射关系,可以通过 `CRC16(key) % 16384` 得到; 然而哈希槽到实例的映射关系则无法通过计算得到

但是实际客户端在访问 redis 集群的时候,只需要连接上任意一个实例,就可以访问整个集群当中其他实例上的数据,这是如何做到的 -> redis 的 `Gossip` 协议

#### 客户端如何查询具体某个 key

集群稳定运行一段时间后,节点之间通过 `Gossip` 协议可以保证每个节点都有全量的哈希槽信息

这样客户端连接任意一个实例,都能够获得整个集群的哈希槽分配情况,并且把这个分配信息缓存到自己的本地

当客户端需要访问一条数据时,首先根据 `CRC16(key) % 16384` 得到当前 `key` 所属的哈希槽,再根据自己维护的实例和哈希槽的映射关系表来访问 `key` 所在的实例

实际上,哈希槽和实例的对应关系也并不是一成不变的; 对于业务压力大的时候,需要新增 redis 实例; 自然也会有减少 redis 实例的情况

redis 为了负载均衡,当实例个数发生变化的时候,会将哈希槽全部重新分配一次; 此时实例之间继续通过一定的通信方式将哈希槽的配置信息互相传递,然而客户端该怎么办呢

redis 提供了一种 `重定向机制`,就是当客户端通过本地缓存的旧哈希槽实例映射表访问具体某个 `key` 时,如果此时的实例上并没有这个 `key` 值,就会向客户端回复一个 `MOVED` 指令, `MOVED`
指令里面就包含了 `key` 所在最新实例的 ip 地址和端口等信息

```
GET testkey
MOVED 7800 172.16.19.3:6379
```

其中 `7800` 表示当前 `key` 所处第 `7800` 个哈希槽,而当前哈希槽归 `172.16.19.3:6379` 这个实例维护; 这样一来客户端就可以重新向新的实例发起请求了

同时客户端还会把最新的哈希槽实例映射关系更新到本地的缓存,以便下次可以直接访问而不再需要重定向 `MOVED` 了

![img_3.png](https://tva1.sinaimg.cn/large/008vK57jgy1h81m11azd2j30hy0f1dk7.jpg)

#### 哈希槽迁移时查询数据

有一种场景,就是当实例数量发生变更,redis 在做哈希槽迁移时,此时客户端向一个正在发生哈希槽迁移的实例发起请求,此时客户端会受到一条回复

```
GET testkey
(error) ASK 7800 172.16.19.5:6379
```

其中 `7800` 表示当前请求的 `key` 所处的哈希槽, 返回 `ASK` 命令表示当前哈希槽正处于迁移状态, `172.16.19.5:6379` 表示数据所处的最新实例地址

此时客户端需要再向实例发起 `ASKING` 命令,表示 **允许** 让实例返回当前请求的数据,接下来再发送 `GET` 命令得到具体的数据

![img_4.png](https://tva1.sinaimg.cn/large/008vK57jgy1h81m15sl7cj30j20ef42s.jpg)

#### MOVED 和 ASK

`MOVED` 重定向指令是在哈希槽已经完成了迁移后,请求到老实例时回复的指令,此时客户端会根据老实例回复的信息更新自己本地缓存的哈希槽实例映射表

`ASK` 指令是在哈希槽正在迁移时,请求到老实例回复的指令; 此时客户端需要根据老实例回复的 `key` 所在的新实例发送 `ASKING` 指令表示允许从正在迁移哈希槽的实例中读取数据; 再发送 `GET` 指令真正读取数据;
此时客户端并不会更新自己本地缓存的哈希槽实例映射表
