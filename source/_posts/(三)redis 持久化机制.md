---
title: (三)redis 持久化机制
date: 2022-11-10 09:25:33
index_img: /img/redis.png
categories:
  - redis
tags:
  - redis
---

### redis 的持久化机制

由于 redis 是内存型数据库,当 redis 实例发生异常宕机时,其内存里面的数据将会全部丢失; 所以 redis 也需要通过持久化操作来避免异常宕机导致的数据丢失问题发生

redis 提供了 3 种持久化方式:

1. AOF 日志
2. RDB 内存快照
3. MIX 两者的混合模式

### AOF 日志

mysql 也有写日志,而且 mysql 的特性是写 `前日志` 也就是说在实际的数据写入之前,先写日志

而 redis 则恰恰相反,redis 是写 `后日志` 也就是当数据写入内存之后,才会记录日志; 要弄清楚为什么 redis 写 `后日志` 需要先了解 `AOF` 日志究竟保存了什么内容

相比于 mysql 的 `redo log`,记录的是修改后的数据,也就是哪个库那张表那个数据行多少偏移量上修改了什么

而 redis 的 `AOF` 日志也是类似于 `redo log` 记录的是什么 `key` 发生了什么修改,其组成部分如下:

```
*3
$3
set
$7
testkey
$9
testvalue
```

`*3` 表示当前操作命令有 3 个部分组成,每个部分都是由 `$+数字` 开头,后面紧跟跟具体的命令或者操作数; `$` 后面的 `数字` 表示当前命令或者操作数占用的字节数

`$3 set` 表示 `set` 指令占用了 3 个字节, `$7 testkey` 表示操作数 `testkey` 占用了 7 个字节

为什么 redis 采用写 `后日志` 的方式,说到底还是为了快,为了性能

如果 redis 已经将命令成功执行了,则表示命令本身的语法和操作并没有问题,无需进行额外的校验,可以直接写到日志里面

如果说是写 `前日志` 的话,还需要对命令进行语法检查,或者一致性检查; 例如 mysql 的唯一键冲突,或者记录不存在等等检查,可以节约系统资源

如果不进行前置检查,直接将命令写入日志的话,如果命令本身是错误的在使用日志做数据恢复的时候,就会发生报错

`AOF` 日志的缺点

1. 如果写入内存后,还没来得及写入 `AOF` 日志,此时宕机会导致数据丢; 如果 redis 用于缓存,还能从数据库里面恢复数据; 如果 redis 用作数据库的话,丢失的数据将无法恢复
2. `AOF` 写日志不阻塞当前命令执行,但是写 `AOF` 日志也是在主线程中执行的,如果写盘的 IO 压力过大,将会严重影响后续命令的执行

#### AOF 的回写策略

为了解决主线程写 `AOF` 日志导致的阻塞问题,redis 提供了 3 种写 `AOF` 日志的策略

1. Always 实时写:类似于 mysql 的同步刷盘,每次命令执行后,都立即写入 `AOF` 日志; 这样做数据可靠性最强,但是性能较低
2. Everysec 每秒写回:类似于 mysql 的实时写延时刷,每次命令执行后,先写入 `AOF` 的内存缓冲区,依靠其他后台线程每 1s 将 `AOF` 内存缓冲区内的数据刷入磁盘
3. No 操作系统控制刷盘时机:类似于 mysql 的延时写,每次命令执行后,只写入 `AOF` 内存缓冲区; 至于什么时候刷盘,由操作系统决定; 性能最高但是数据可靠性最低

对于第 2 点,如果发生异常宕机,仍然会丢失 1s 之前的数据

#### AOF 重写机制

由于 `AOF` 是以文件的形式记录所有接收到的 **写请求**, 必不可免会导致 `AOF` 日志文件过大的情况; 即使是顺序写,对于一个大文件来说起磁盘写入的性能仍然低下

而且如果要使用 `AOF` 日志来做数据恢复的话,一个巨大的 `AOF` 日志势必导致数据恢复的时间非常缓慢,也会影响到 redis 的正常使用

redis 为了避免 `AOF` 日志文件越写越大,引入了 `AOF` 重写机制,其具体过程如下: 进行 `AOF` 重写时,会基于当前 redis 数据库现状创建一个新的 `AOF` 日志文件,会遍历所有的键值对,使用 `一条` 命令来记录写入

为什么说重写的 `AOF` 日志可以减小日志文件的大小呢?

因为 `AOF` 日志是追加写入的方式,也就是说 redis 对于每一条写记录,都会记录对应的 `AOF` 日志,对于一个 `key` 的重复

![img.png](https://tva1.sinaimg.cn/large/008vK57jgy1h80fmi1e2yj332a0u017w.jpg)

对于写入一个 `list` 来说, `AOF` 日志会记录完整的所有写操作,而重写的 `AOF` 日志则是只会记录当前最新状态的记录

即无论对 `list` 有多少次操作,重写 `AOF` 时的状态只有确切的一条,就只用记录这一条日志就够了

为了避免重写 `AOF` 日志对主线程的阻塞,redis 实际上有专门的后台线程 `bgrewriteaof` 去处理重写 `AOF` 日志

**一处拷贝,两处日志**

* 一处拷贝是指: 当需要进行 `AOF` 日志重写时,此时的主线程会 `fork` 一个子线程出来,`fork` 出来的子线程拥有与重写时主线程完全一致的内存数据; 这样子线程就可以在不阻塞主线程的情况下,在后台异步的重写 `AOF` 日志

之前提到过,为了避免写 `AOF` 日志时写盘速率影响到主线程,此时主线程实际上写入的是 `AOF` 日志缓冲区,然后按照配置的刷盘策略去将日志缓冲区的记录刷到磁盘上的 `AOF` 文件里

由于重写 `AOF` 时是 `fork` 的子线程,而在 `fork` 之后还会有新的写请求进来,这样子线程的内存数据和主线程的内存数据就会产生不一致

* 两处日志就是为了解决上述的不一致问题: 当主线程 `fork` 之后继续处理新的写请求时,此时不仅仅会将新的写请求写入 `AOF` 日志缓冲区,还会继续写入 `AOF` 重写日志缓冲区; 这样当子线程完成 `AOF` 重写之后,再把 `AOF` 重写缓冲区内的增量写请求继续重写后与当前结果合并,这样一个完整的 `AOF` 重写日志就完成了,而且 `fork` 之后的写请求也不会丢失

![img_1.png](https://tva1.sinaimg.cn/large/008vK57jgy1h80fn02t77j30j108xdib.jpg)

#### AOF 重写时的性能问题

重写 `AOF` 日志时,虽然使用了子线程在后台操作,但是仍然有阻塞主线程的场景

1. 主线程 `fork` 子线程时,需要拷贝虚拟页表,可能会阻塞
2. 当有 `bigkey` 写入时,根据写时复制优化,需要拷贝 `key` 的全量数据到新的内存页里面,可能会阻塞
3. 当重写 `AOF` 日志完成后,应用重写 `AOF` 缓冲区时,可能会阻塞

#### 写时复制

什么是写时复制

如果 `fork` 子线程时全量拷贝主线程的内存数据,此时很有可能导致内存不够,为了避免全量拷贝主线程内存,操作系统在做 `fork` 时引入了写时复制的概念

![img_2.png](https://tva1.sinaimg.cn/large/008vK57jgy1h80fn62qwej30hd0fhtar.jpg)

当主线程需要写入数据的时候,如果此时数据页正好在内存当中,则会在内存上单独分配一块内存出来将原有的内存页复制到新页里面,主线程的数据全部写入新的数据页

这样原来 `fork` 的子线程仍然访问原来的老数据页,使得在做 `AOF` 重写时,主线程和子线程的读写互不影响

且写时复制对于 redis 这种读多写少的数据库,能够减少数据页的分配,提高内存的使用率,减少 `fork` 子线程的阻塞时间

### RDB 内存快照

由于 `AOF` 日志记录的是每一条操作指令和操作数,并不是实际的数据; 所以在使用 `AOF` 日志进行数据恢复的时候,需要 redis 把这些指令和操作数全部拿出来重新执行一遍

且 `AOF` 日志记录所有写指令,如果日志文件过大,在做数据恢复的时候将严重影响 redis 性能

redis 的另一种持久化方式: `RDB` 内存快照

`RDB` 就是在某一时刻,记录了 redis 瞬间的所有数据和状态,并且以文件的形式持久化到磁盘上

与 `AOF` 相比, `RDB` 记录的是某一时刻的全量数据,而 `AOF` 则是记录的数据的操作; 所以在做数据恢复的时候,可以很方便的把 `RDB` 文件直接导入到 redis 当中

#### RDB 快照的范围

要明确一点 `RDB` 做的是 `全量` 数据快照; 如果 redis 里面的数据量非常多,那么 `全量` 快照很有可能阻塞主线程的工作; 类比于 `AOF` 日志, redis 也提供了后台线程执行快照

`bgsave` 命令可以创建一条后台子线程专门处理当前时刻的 `RDB` 快照数据,避免阻塞主线程

#### RDB 快照时,写请求如何处理

对于业务系统来说,如果为了处理一次 `RDB` 快照,而让整个 redis 进入只读状态,这是不允许接收的; 然而如果在做 `RDB` 快照时仍然有写请求进入,此时就可能导致 `RDB` 快照数据和 redis 本身保存的数据不一致问题

对于写请求, `RDB` 类似于 `AOF` 仍然采用 `写时复制` 技术,保证数据的一致性; 当主线程需要写入数据时,会将这份数据的内存页复制出一个新的内存页; 主线程的写入操作全部放到新的内存页上; 同时子线程的 `RDB` 快照也会读取新的内存页,保证数据的一致性不被破坏

![img_3.png](https://tva1.sinaimg.cn/large/008vK57jgy1h80fnb7r21j30i709qtao.jpg)

#### RDB 快照的频率

为了保证数据尽可能的最新,`RDB` 快照的频率必然也要变得更加频繁; 这样可以减少两次快照之间异常宕机导致的改动丢失; 但是 `RDB` 快照的频率也不是越快越好

1. 虽然 `bgsave` 子线程做快照时不阻塞主线程,但是每次子线程都要从主线程 `fork` 出来,而 `fork` 操作会把主线程的虚拟内存映射表全部赋值给子线程; 如果 redis 里面的数据量非常大,这里的 `fork` 操作也会影响到主线程的处理
2. 由于 `RDB` 快照每次都记录全量的数据,而频繁地将全量数据写入磁盘; 也会导致 redis 整体性能下降

#### 增量 RDB

由于每次全量 `RDB` 需要记录的数据太多了,而放慢 `RDB` 频率又会导致宕机时丢失更多的数据; redis 引入了增量 `RDB` 技术

即在一次全量 `RDB` 之后,后面仅仅记录发生改动的数据,即只做增量 `RDB` 操作

增量 `RDB` 看起来很美好,但实际上并不是如此,因为 redis 要为每条记录维护元数据,而这些元数据大小是固定的; 如果说大量很小的字段被增量写入 `RDB` 可能一条记录也就 2,3 个字节; 但是其元数据可能固定高达 8 个字节; 这样 redis 就不得不为这些小字段去维护大量的元数据; 浪费大量内存,显得有点得不偿失

#### 混合 AOF 和 RDB 持久化

在 redis 4.0 以后引入了混合模式: 即以一定的间隔做全量 `RDB` 快照; 同时在快照期间通过记录 `AOF` 日志的形式保存增量数据

这样即保证了有 `RDB` 快照可以快速恢复到上一时刻,也保证了快照期间的写请求不会丢失,还保证了 `AOF` 日志文件不会变得过于庞大,因为它只记录每次快照期间的增量数据

![img_4.png](https://tva1.sinaimg.cn/large/008vK57jgy1h80fngtx5rj30iu0blmzs.jpg)

在下一次发生全量快照的时候,直接清空 `AOF` 日志即可,因为下一次全量快照已经包含了这部分 `AOF` 日志记录的数据,这样进一步减小了 `AOF` 日志文件的大小