---
title: (十五)mysql 一主多从如何进行主从切换
date: 2022-11-07 13:18:25
index_img: /img/mysql.png
categories:
  -mysql
tags:
  - 数据库
---

### 一主多从的结构

![img.png](https://tva1.sinaimg.cn/large/008vK57jgy1h7xg26tow1j30il0dxq6q.jpg)

其中 A 和 A' 互为主备关系(即双 M 结构),BCD 三个从库同步主库 A 的数据,只提供读服务

当发生主从切换的时候,从库 A' 当选新的主库,此时 BCD 三个库需要重新连接到新的主库 A' 上

### 基于位点的朴素主从切换

以从库 B 为例,当需要把 B 的主库切换到 A' 时,需要执行 `change master` 指令,然后需要指定新主库的 `ip,端口,用户名,密码,binlog 日志,以及 binlog 日志位点` 这 6 个值

其中 `binlog` 日志位点是比较关键的信息,包含了从库 B 应该从新的主库的 `binlog` 日志的那个位置开始同步

如果这个位置选早了,会导致重复的事务再次被同步; 如果选晚了,会导致有些事务丢失

一种同步方式为:

1. 等待新主库 A' 完成 `relay log` 的消费
2. 通过工具解析原主库的最后一条事务记录,得到发生主从切换时的 `binlog` 日志和对应的位点
3. 新主库 A' 将这个位点发给从库 B 告知从库从这里开始往后解析 `binlog`

这种统计方式并不准确:

假如在原来的主库在执行事务 R 之后,已经将 `binlog` 发送给从库 A' 和从库 B,在这个 T 时刻发生了主从切换

此时 A' 还在继续消费 A 的中转日志,从库 B 已经把刚刚接收到的事务 R 同步到自己的实例当中; 当发生主从切换时,新的主库 A' 告知从库 B 应当从最新的位点,即原来主库的最后一条事务 R 开始执行; 这样因为从库 B
已经执行过事务 R 了,会产生主键重复的错误

在主从切换遇到主键冲突一般有两种解决方案:

1. 手动跳过一个事务
2. 设置跳过指定类型的错误:例如唯一键冲突,或者删除行不存在

对于第二种方案,在主从切换稳定下来之后需要再次关闭,避免真正产生数据不一致后被跳过

### GTID 全局事务 id

根据前面事务的介绍,InnoDB 会在每个事务创建的时候,为其分配一个自增的 `long` 类型的事务 `trx_id`, 在配合上当前数据库实例的唯一 `server_id` 就构成了 `GTID`
其定义为: `GTID=server_id:trx_id`

在启动 `GTID` 之后,每个事务都有一个唯一确定的 `GTID`,有两种分配方式:

1. `gtid_next=automatic` 自增分配
2. `gtid_next='current_gtid` 手动指定一个事务的 `GTID` 值
   * 若这个 `current_gtid` 已经存在于当前实例的 `GTID` 集合里面,则当前实例在拿到这条事务后会跳过不执行
   * 若不存在于当前实例的 `GTID` 集合,则把这个 `GTID` 分配给当前即将执行的事务,然后在分配下一个 `GTID` 给下一个事务

每个实力都维护了一个 `GTID` 集合,用来记录 **当前实例已经执行过的所有事务**

举个简单的例子:

假设实例 X 已经插入了数据 `(1,1)` 且 `binlog` 里面记录的实例 X 的 `insert` 语句之前有一条 `SET` 语句,为这个事务设置了 `GTID=xxx`

实例 X 是实例 Y 的从库,而且主库 Y 也插入了一条记录 `(1,1)` 且 `binlog` 里面 `insert` 语句之前也有一条 `SET` 语句,为这个事务设置了 `GTID=yyy`

若此时主库 Y 将自己的 `binlog` 发送给从库 X 进行同步,显然从库 X 会发生主键冲突的错误,导致主从同步停止

根据上面 `GTID` 分配方式的,第二种,可以手动为从库 X 将产生主键冲突的事务 `GTID` 加入到实例 X 维护的 `GTID` 集合里面,来达到跳过这条主键冲突的事务

```sql
set gtid_next=yyy;
begin;
commit;
set gtid_next=automatic;
```

这样通过提交一个 **空事务** 来把产生冲突的 `GTID` 加入到实例 X 维护的 `GTID` 集合里面,这样同步实例 Y 的语句时,就会跳过这条事务,也就不会再出现主键冲突; 并且在手动 `SET` 之后,还将 `GTID` 更新设置自增,这样 mysql 就可以继续按照原有的序号分配新的 `GTID` 给新的事务

### 基于 GTID 的主从切换

当启动了 `GTID` 后,假设新主库 A' 的 `GTID` 集合为 `set_a`, 从库 B 的 `GTID` 集合为 `set_b`

此时主从切换的过程如下:

1. 从库 B 指定新的主库 A'
2. 从库 B 把自己的 `set_b` 发送给主库 A'
3. 主库 A' 计算出 `set_a` 和 `set_b` 之前的差异,找到所有存在于 `set_a` 但是不存在于 `set_b` 的集合 `set_a'` ,并且判断主库 A' 上面的 `binlog` 里面是否包含 `set_a'`
   * 如果 `binlog` 包含所有 `set_a'`,就找到 `set_b` 第一个不存在的事务,并把这个事务的 `GTID` 发送给 B
   * 如果 `binlog` 不包含,则认为 `binlog` 数据不完整,直接报错
4. 主库 A 从 `set_a'` 里面第一个不存在于 `set_b` 的事务开始,顺序读取 `binlog` 发送给从库 B 进行主从同步

这里有个大前提保证: **只要产生主从关系,就必须保证主库发送给从库的 `binlog` 是完整的,否则会导致主从数据不一致**

